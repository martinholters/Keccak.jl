var documenterSearchIndex = {"docs":
[{"location":"#Keccak.jl-Documentation","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"","category":"section"},{"location":"#Keccak.absorb","page":"Keccak.jl Documentation","title":"Keccak.absorb","text":"absorb(sponge::Sponge, data::Union{AbstractVector{UInt8},NTuple{<:Any,UInt8}})\n\nAbsorbs the provided data into the sponge and returns the updated sponge.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\nIf the sponge holds SIMD.Vecs, the same data is used for every data path.\n\n\n\n\n\nabsorb(sponge::Sponge, data1, ..., dataN)\n\nAbsorbs the provided data into the SIMD sponge and returns the updated sponge.\n\nThe sponge has to hold SIMD.Vec{N}s, matching the number of provided data parameters, and their lengths must be equal, i.e. length(data1) == ... == length(dataN) has to hold.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.pad","page":"Keccak.jl Documentation","title":"Keccak.pad","text":"pad(sponge)\n\nApplies padding to sponge and returns the updated sponge.\n\nMust be called after the last call to absorb and before the first call to squeeze.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.squeeze","page":"Keccak.jl Documentation","title":"Keccak.squeeze","text":"sponge′, data = squeeze(sponge, len)\n\nSqueezes len bytes from the sponge and returns the updated sponge and the obtained data.\n\nIf len is a Val, the data is returned as a tuple, otherwise as a Vector{UInt8}.\n\nIf the sponge holds SIMD.Vec{N}s, the returned data is an N-tuple of the data squeezed form the respective data paths.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.keccak_p","page":"Keccak.jl Documentation","title":"Keccak.keccak_p","text":"keccak_p(state, ::Val{nrounds})\n\nThe Kᴇᴄᴄᴀᴋ-p permutation function as defined in FIPS-202, with the number of rounds given by nrounds. The input state as well as the returned updated state are 25-tuples of unsigned integers of type T. Their LSB-first serialization corresponds to the bitstrings S and S′ in FIPS-202; its length b is determined by the type T. E.g. for T==UInt64, one obtains the commonly used b = 25 ⋅ 64 = 1600.\n\nFor example, for b=800 (hence T==UInt32), S=1000...000 corresponds to state == (0x00000001, (0x00000000 for _ in 2:25)...).\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances. E.g, for state::NTuple{25,SIMD.Vec{4,UInt64}}, it holds that\n\njulia> SIMD.Vec.((keccak_p(map(s -> s[n], state)) for n in 1:4)...) == keccak_p(state)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.KeccakP","page":"Keccak.jl Documentation","title":"Keccak.KeccakP","text":"KeccakP{nrounds}\n\nConvenience wrapper for keccak_p with nrounds fixed.\n\nThis allows replacing constructions like state -> keccak_p(state, Val(nrounds)) with KeccakP{nrounds}():\n\njulia> const f1 = KeccakP{23}()\nKeccakP{23}()\n\njulia> const f2 = state -> keccak_p(state, Val(23))\n#2 (generic function with 1 method)\n\njulia> f1(state) == f2(state) == keccak_p(state, Val(23)) # for suitable state\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.KeccakPad","page":"Keccak.jl Documentation","title":"Keccak.KeccakPad","text":"KeccakPad\n\nA padding function performing the Kᴇᴄᴄᴀᴋ pad10*1 padding with optional suffix bits inserted first for domain separation. These suffix bits are specified by providing a byte that includes the first 1 bit of the padding.\n\nE.g. for SHA3, the domain separation suffix is 01, so the padding appends 011000...0001. Noting the LSB-first convention, the first byte of the padding thus has to be 0b00000110 == 0x06, and the corresponding padding function would be instantiated with KeccakPad(0x06).\n\nnote: Note\nOnly up to six domain separation suffix bits are supported, so including the first padding 1 bit, the first byte has be between 0b00000001 (no suffix bits) and 0b01111111 (suffix 111111).\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.KeccakSponge","page":"Keccak.jl Documentation","title":"Keccak.KeccakSponge","text":"KeccakSponge{R,T,nrounds}\n\nA Sponge specialization for Kᴇᴄᴄᴀᴋ:\n\nThe permutation function is KeccakP{nrounds}.\nThe sponge contents are a 25-tuple of T, which must be an unsigned integer or a SIMD.Vec thereof.\nThe rate in bits is given by 8*sizeof(T)*R (or 8*sizeof(eltype(T))*R) if T<:SIMD.Vec).\n\n\n\n\n\n","category":"type"},{"location":"#Internals","page":"Keccak.jl Documentation","title":"Internals","text":"","category":"section"},{"location":"#Sponge","page":"Keccak.jl Documentation","title":"Sponge","text":"","category":"section"},{"location":"#Keccak.Sponge","page":"Keccak.jl Documentation","title":"Keccak.Sponge","text":"Sponge{R,T<:NTuple,Fxfm,Fpad}\n\nCryptographic sponge holding a fixed-length permutation function, state of that length, a function to apply padding, and an offset for byte-wise input and output.\n\nA Sponge allows absorbing and squeezing arbitrary-sized data chunks. Once per every rate bytes absorbed or squeezed, the permutation function is invoked. After the last absorb and before the first squeeze, pad should be called to perform any necessary padding. I.e. the valid sequence of operations on a sponge is: Any number (including zero) calls to absorb, exactly one call to pad, any number (including zero) calls to squeeze.\n\nNote that a Sponge is immutable; any operations updating it return an updated Sponge instead of mutating the given one.\n\nType parameters\n\nT: type of the NTuple holding the sponge contents\nR: the rate in units of the state elements (eltype(T))\nFxfm: type of the permutation function\nFpad: type of the padding function\n\nFields\n\ntransform: the permutation function invoked for every rate bytes absorbed or squeezed\npad: the padding function invoked by pad(::Sponge)\nstate: the sponge contents\nk: the write (while absorbing) or read (while squeezing) byte offset inside the state, between 0 (inclusive) and R*sizeof(eltype(T)) (exclusive)\n\nSIMD support\n\nIf T<:SIMD.Vec (i.e. the state tuple holds SIMD.Vecs), absorbing and squeezing treats the individual data paths separately (and the rate in bytes is given by R*sizeof(eltype(eltype(T)))) in this case.)\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.update","page":"Keccak.jl Documentation","title":"Keccak.update","text":"update(sponge::Sponge, state, k)\n\nReturn a new Sponge of the same type as sponge with the same transform function, but with state and k replaced with the given values.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.rate","page":"Keccak.jl Documentation","title":"Keccak.rate","text":"rate(sponge::Sponge)\n\nReturns the rate (in bytes) of the given sponge.\n\n\n\n\n\n","category":"function"},{"location":"#Kᴇᴄᴄᴀᴋ-Helpers","page":"Keccak.jl Documentation","title":"Kᴇᴄᴄᴀᴋ Helpers","text":"","category":"section"},{"location":"#Keccak.ℓ","page":"Keccak.jl Documentation","title":"Keccak.ℓ","text":"ℓ(::Type{T<:Unsigned})\n\nReturns the base-2 logarithm of the bitwidth of values of type T.\n\nExamples\n\njulia> ℓ(UInt32)\n5\n\njulia> 2^5\n32\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.rc","page":"Keccak.jl Documentation","title":"Keccak.rc","text":"rc(t)\n\nEvaluate t rounds of a linear feedback shift register and return the leading bit after the final round as specified in Algorithm 5 of FIPS-202.\n\nThis function is used for computing the round constants by round_consts.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.round_consts","page":"Keccak.jl Documentation","title":"Keccak.round_consts","text":"round_consts(::Type{T}, ::Val{nrounds}=Val(12+2ℓ(T)))\n\nCompute the Keccak round constants for lane length w corresponding to the bitwidth of T and the given number fo rounds nrounds.\n\nThe return value is a tuple of Ts containing the round constants for round indices 12+2ℓ(T)-nrounds to 12+2ℓ(T)-1 in that order. The default for nrounds results in the first round index being 0.\n\nnote: Note\nIt is valid to have nrounds>12+2ℓ(T), so that round index starts negative.\n\nExamples\n\njulia> round_consts(UInt16)\n(0x0001, 0x8082, 0x808a, 0x8000, 0x808b, 0x0001, 0x8081, 0x8009, 0x008a, 0x0088, 0x8009, 0x000a, 0x808b, 0x008b, 0x8089, 0x8003, 0x8002, 0x0080, 0x800a, 0x000a)\n\njulia> round_consts(UInt8)\n(0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(10))\n(0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(20))\n(0x02, 0x8a, 0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\n\n\n\n\n","category":"function"},{"location":"#Kᴇᴄᴄᴀᴋ-step-mappings","page":"Keccak.jl Documentation","title":"Kᴇᴄᴄᴀᴋ step mappings","text":"","category":"section"},{"location":"","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"These functions follow the specification in section 3.2 of FIPS-202.","category":"page"},{"location":"#Keccak.ι","page":"Keccak.jl Documentation","title":"Keccak.ι","text":"ι(state, RC)\n\nPerform the step mapping ι (round-dependent modification of lane[0,0]) of the Keccak algorithm and return the updated state.\n\nInstead of the round index as in FIPS-202, the corresponding round constant RC is expected as the second argument.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.θ","page":"Keccak.jl Documentation","title":"Keccak.θ","text":"θ(state)\n\nPerform the step mapping θ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.π","page":"Keccak.jl Documentation","title":"Keccak.π","text":"π(state)\n\nPerform the step mapping π (permutation of the lanes) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.χ","page":"Keccak.jl Documentation","title":"Keccak.χ","text":"χ(state)\n\nPerform the nonlinear step mapping χ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.ρ","page":"Keccak.jl Documentation","title":"Keccak.ρ","text":"ρ(state)\n\nPerform the step mapping ρ (bit rotation in each lane) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"}]
}
