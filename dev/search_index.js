var documenterSearchIndex = {"docs":
[{"location":"#Keccak.jl-Documentation","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"","category":"section"},{"location":"#Keccak.sha3_224","page":"Keccak.jl Documentation","title":"Keccak.sha3_224","text":"sha3_224(data)\n\nComputes the SHA3-224 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a 28-tuple of UInt8s.\n\nExamples\n\njulia> sha3_224(fill(0xa3, 200))\n(0x93, 0x76, 0x81, 0x6a, 0xba, 0x50, 0x3f, 0x72, 0xf9, 0x6c, 0xe7, 0xeb, 0x65, 0xac, 0x09, 0x5d, 0xee, 0xe3, 0xbe, 0x4b, 0xf9, 0xbb, 0xc2, 0xa1, 0xcb, 0x7e, 0x11, 0xe0)\n\n\n\n\n\nsha3_224(data1, ..., dataN)\n\nComputes the SHA3-224 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 28-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_256","page":"Keccak.jl Documentation","title":"Keccak.sha3_256","text":"sha3_256(data)\n\nComputes the SHA3-256 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a 32-tuple of UInt8s.\n\nExamples\n\njulia> sha3_256(fill(0xa3, 200))\n(0x79, 0xf3, 0x8a, 0xde, 0xc5, 0xc2, 0x03, 0x07, 0xa9, 0x8e, 0xf7, 0x6e, 0x83, 0x24, 0xaf, 0xbf, 0xd4, 0x6c, 0xfd, 0x81, 0xb2, 0x2e, 0x39, 0x73, 0xc6, 0x5f, 0xa1, 0xbd, 0x9d, 0xe3, 0x17, 0x87)\n\n\n\n\n\nsha3_256(data1, ..., dataN)\n\nComputes the SHA3-256 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 32-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_384","page":"Keccak.jl Documentation","title":"Keccak.sha3_384","text":"sha3_384(data)\n\nComputes the SHA3-384 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a 48-tuple of UInt8s.\n\nExamples\n\njulia> sha3_384(fill(0xa3, 200))\n(0x18, 0x81, 0xde, 0x2c, 0xa7, 0xe4, 0x1e, 0xf9, 0x5d, 0xc4, 0x73, 0x2b, 0x8f, 0x5f, 0x00, 0x2b, 0x18, 0x9c, 0xc1, 0xe4, 0x2b, 0x74, 0x16, 0x8e, 0xd1, 0x73, 0x26, 0x49, 0xce, 0x1d, 0xbc, 0xdd, 0x76, 0x19, 0x7a, 0x31, 0xfd, 0x55, 0xee, 0x98, 0x9f, 0x2d, 0x70, 0x50, 0xdd, 0x47, 0x3e, 0x8f)\n\n\n\n\n\nsha3_384(data1, ..., dataN)\n\nComputes the SHA3-384 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 48-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_512","page":"Keccak.jl Documentation","title":"Keccak.sha3_512","text":"sha3_512(data)\n\nComputes the SHA3-512 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a 64-tuple of UInt8s.\n\nExamples\n\njulia> sha3_512(fill(0xa3, 200))\n(0xe7, 0x6d, 0xfa, 0xd2, 0x20, 0x84, 0xa8, 0xb1, 0x46, 0x7f, 0xcf, 0x2f, 0xfa, 0x58, 0x36, 0x1b, 0xec, 0x76, 0x28, 0xed, 0xf5, 0xf3, 0xfd, 0xc0, 0xe4, 0x80, 0x5d, 0xc4, 0x8c, 0xae, 0xec, 0xa8, 0x1b, 0x7c, 0x13, 0xc3, 0x0a, 0xdf, 0x52, 0xa3, 0x65, 0x95, 0x84, 0x73, 0x9a, 0x2d, 0xf4, 0x6b, 0xe5, 0x89, 0xc5, 0x1c, 0xa1, 0xa4, 0xa8, 0x41, 0x6d, 0xf6, 0x54, 0x5a, 0x1c, 0xe8, 0xba, 0x00)\n\n\n\n\n\nsha3_512(data1, ..., dataN)\n\nComputes the SHA3-512 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 64-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.shake_128","page":"Keccak.jl Documentation","title":"Keccak.shake_128","text":"shake_128(data)\n\nReturns a SHAKE-128 sponge with data absorbed, ready to squeeze from.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s. Appropriate padding is applied by shake_128.\n\n\n\n\n\nshake_128(data, len)\n\nComputes the SHAKE-128 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExamples\n\njulia> shake_128(fill(0xa3, 200), Val(20))\n(0x13, 0x1a, 0xb8, 0xd2, 0xb5, 0x94, 0x94, 0x6b, 0x9c, 0x81, 0x33, 0x3f, 0x9b, 0xb6, 0xe0, 0xce, 0x75, 0xc3, 0xb9, 0x31)\n\n\n\n\n\nshake_128(data1, ..., dataN)\n\nAbsorbs data1, ..., dataN (for N >= 2) into a new N-fold-SIMD SHAKE-128 sponge and pads it.\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The data is absorbed into a fresh (SIMD) SHAKE-128 sponge and padding is applied.\n\nThe returned sponge is ready for being squeezed.\n\n\n\n\n\nshake_128(data1, ..., dataN, len)\n\nComputes the SHAKE-128 hash of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation.\n\nAn N-tuple of the individual hashes of the desired length is returned. The hashes are tuples of UInt8s if len is a Val, Vector{UInt8}s otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.shake_256","page":"Keccak.jl Documentation","title":"Keccak.shake_256","text":"shake_256(data)\n\nReturns a SHAKE-256 sponge with data absorbed, ready to squeeze from.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s. Appropriate padding is applied by shake_256.\n\n\n\n\n\nshake_256(data, len)\n\nComputes the SHAKE-256 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, the hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExamples\n\njulia> shake_256(fill(0xa3, 200), Val(20))\n(0xcd, 0x8a, 0x92, 0x0e, 0xd1, 0x41, 0xaa, 0x04, 0x07, 0xa2, 0x2d, 0x59, 0x28, 0x86, 0x52, 0xe9, 0xd9, 0xf1, 0xa7, 0xee)\n\n\n\n\n\nshake_256(data1, ..., dataN)\n\nAbsorbs data1, ..., dataN (for N >= 2) into a new N-fold-SIMD SHAKE-256 sponge and pads it.\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation. The data is absorbed into a fresh (SIMD) SHAKE-256 sponge and padding is applied.\n\nThe returned sponge is ready for being squeezed.\n\n\n\n\n\nshake_256(data1, ..., dataN, len)\n\nComputes the SHAKE-256 hash of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s, and they all must have the same length as SIMD is used to speed up the hash computation.\n\nAn N-tuple of the individual hashes of the desired length is returned. The hashes are tuples of UInt8s if len is a Val, Vector{UInt8}s otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_224_sponge","page":"Keccak.jl Documentation","title":"Keccak.sha3_224_sponge","text":"sha3_224_sponge()\n\nReturns a sponge suitable for SHA3-224 computation.\n\n\n\n\n\nsha3_224_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-224 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_256_sponge","page":"Keccak.jl Documentation","title":"Keccak.sha3_256_sponge","text":"sha3_256_sponge()\n\nReturns a sponge suitable for SHA3-256 computation.\n\n\n\n\n\nsha3_256_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-256 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_384_sponge","page":"Keccak.jl Documentation","title":"Keccak.sha3_384_sponge","text":"sha3_384_sponge()\n\nReturns a sponge suitable for SHA3-384 computation.\n\n\n\n\n\nsha3_384_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-384 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.sha3_512_sponge","page":"Keccak.jl Documentation","title":"Keccak.sha3_512_sponge","text":"sha3_512_sponge()\n\nReturns a sponge suitable for SHA3-512 computation.\n\n\n\n\n\nsha3_512_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-512 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.shake_128_sponge","page":"Keccak.jl Documentation","title":"Keccak.shake_128_sponge","text":"shake_128_sponge()\n\nReturns a sponge suitable for SHAKE-128 computation.\n\n\n\n\n\nshake_128_sponge(::Val{N})\n\nReturns a sponge suitable for SHAKE-128 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.shake_256_sponge","page":"Keccak.jl Documentation","title":"Keccak.shake_256_sponge","text":"shake_256_sponge()\n\nReturns a sponge suitable for SHAKE-256 computation.\n\n\n\n\n\nshake_256_sponge(::Val{N})\n\nReturns a sponge suitable for SHAKE-256 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.absorb","page":"Keccak.jl Documentation","title":"Keccak.absorb","text":"absorb(sponge::Sponge, data::Union{AbstractVector{UInt8},NTuple{<:Any,UInt8}})\n\nAbsorbs the provided data into the sponge and returns the updated sponge.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\nIf the sponge holds SIMD.Vecs, the same data is used for every data path.\n\n\n\n\n\nabsorb(sponge::Sponge, data1, ..., dataN)\n\nAbsorbs the provided data into the SIMD sponge and returns the updated sponge.\n\nThe sponge has to hold SIMD.Vec{N}s, matching the number of provided data parameters, and their lengths must be equal, i.e. length(data1) == ... == length(dataN) has to hold.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.pad","page":"Keccak.jl Documentation","title":"Keccak.pad","text":"pad(sponge)\n\nApplies padding to sponge and returns the updated sponge.\n\nMust be called after the last call to absorb and before the first call to squeeze.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.squeeze","page":"Keccak.jl Documentation","title":"Keccak.squeeze","text":"sponge′, data = squeeze(sponge, len)\n\nSqueezes len bytes from the sponge and returns the updated sponge and the obtained data.\n\nIf len is a Val, the data is returned as a tuple, otherwise as a Vector{UInt8}.\n\nIf the sponge holds SIMD.Vec{N}s, the returned data is an N-tuple of the data squeezed form the respective data paths.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.keccak_p","page":"Keccak.jl Documentation","title":"Keccak.keccak_p","text":"keccak_p(state, ::Val{nrounds})\n\nThe Kᴇᴄᴄᴀᴋ-p permutation function as defined in FIPS-202, with the number of rounds given by nrounds. The input state as well as the returned updated state are 25-tuples of unsigned integers of type T. Their LSB-first serialization corresponds to the bitstrings S and S′ in FIPS-202; its length b is determined by the type T. E.g. for T==UInt64, one obtains the commonly used b = 25 ⋅ 64 = 1600.\n\nFor example, for b=800 (hence T==UInt32), S=1000...000 corresponds to state == (0x00000001, (0x00000000 for _ in 2:25)...).\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances. E.g, for state::NTuple{25,SIMD.Vec{4,UInt64}}, it holds that\n\njulia> SIMD.Vec.((keccak_p(map(s -> s[n], state)) for n in 1:4)...) == keccak_p(state)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.KeccakP","page":"Keccak.jl Documentation","title":"Keccak.KeccakP","text":"KeccakP{nrounds}\n\nConvenience wrapper for keccak_p with nrounds fixed.\n\nThis allows replacing constructions like state -> keccak_p(state, Val(nrounds)) with KeccakP{nrounds}():\n\njulia> const f1 = KeccakP{23}()\nKeccakP{23}()\n\njulia> const f2 = state -> keccak_p(state, Val(23))\n#2 (generic function with 1 method)\n\njulia> f1(state) == f2(state) == keccak_p(state, Val(23)) # for suitable state\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.KeccakPad","page":"Keccak.jl Documentation","title":"Keccak.KeccakPad","text":"KeccakPad\n\nA padding function performing the Kᴇᴄᴄᴀᴋ pad10*1 padding with optional suffix bits inserted first for domain separation. These suffix bits are specified by providing a byte that includes the first 1 bit of the padding.\n\nE.g. for SHA3, the domain separation suffix is 01, so the padding appends 011000...0001. Noting the LSB-first convention, the first byte of the padding thus has to be 0b00000110 == 0x06, and the corresponding padding function would be instantiated with KeccakPad(0x06).\n\nnote: Note\nOnly up to six domain separation suffix bits are supported, so including the first padding 1 bit, the first byte has be between 0b00000001 (no suffix bits) and 0b01111111 (suffix 111111).\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.KeccakSponge","page":"Keccak.jl Documentation","title":"Keccak.KeccakSponge","text":"KeccakSponge{R,T,nrounds}\n\nA Sponge specialization for Kᴇᴄᴄᴀᴋ:\n\nThe permutation function is KeccakP{nrounds}.\nThe sponge contents are a 25-tuple of T, which must be an unsigned integer or a SIMD.Vec thereof.\nThe rate in bits is given by 8*sizeof(T)*R (or 8*sizeof(eltype(T))*R) if T<:SIMD.Vec).\n\n\n\n\n\n","category":"type"},{"location":"#Internals","page":"Keccak.jl Documentation","title":"Internals","text":"","category":"section"},{"location":"#Sponge","page":"Keccak.jl Documentation","title":"Sponge","text":"","category":"section"},{"location":"#Keccak.Sponge","page":"Keccak.jl Documentation","title":"Keccak.Sponge","text":"Sponge{R,T<:NTuple,Fxfm,Fpad}\n\nCryptographic sponge holding a fixed-length permutation function, state of that length, a function to apply padding, and an offset for byte-wise input and output.\n\nA Sponge allows absorbing and squeezing arbitrary-sized data chunks. Once per every rate bytes absorbed or squeezed, the permutation function is invoked. After the last absorb and before the first squeeze, pad should be called to perform any necessary padding. I.e. the valid sequence of operations on a sponge is: Any number (including zero) calls to absorb, exactly one call to pad, any number (including zero) calls to squeeze.\n\nNote that a Sponge is immutable; any operations updating it return an updated Sponge instead of mutating the given one.\n\nType parameters\n\nT: type of the NTuple holding the sponge contents\nR: the rate in units of the state elements (eltype(T))\nFxfm: type of the permutation function\nFpad: type of the padding function\n\nFields\n\ntransform: the permutation function invoked for every rate bytes absorbed or squeezed\npad: the padding function invoked by pad(::Sponge)\nstate: the sponge contents\nk: the write (while absorbing) or read (while squeezing) byte offset inside the state, between 0 (inclusive) and R*sizeof(eltype(T)) (exclusive)\n\nSIMD support\n\nIf T<:SIMD.Vec (i.e. the state tuple holds SIMD.Vecs), absorbing and squeezing treats the individual data paths separately (and the rate in bytes is given by R*sizeof(eltype(eltype(T)))) in this case.)\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.update","page":"Keccak.jl Documentation","title":"Keccak.update","text":"update(sponge::Sponge, state, k)\n\nReturn a new Sponge of the same type as sponge with the same transform function, but with state and k replaced with the given values.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.rate","page":"Keccak.jl Documentation","title":"Keccak.rate","text":"rate(sponge::Sponge)\n\nReturns the rate (in bytes) of the given sponge.\n\n\n\n\n\n","category":"function"},{"location":"#Kᴇᴄᴄᴀᴋ-Helpers","page":"Keccak.jl Documentation","title":"Kᴇᴄᴄᴀᴋ Helpers","text":"","category":"section"},{"location":"#Keccak.ℓ","page":"Keccak.jl Documentation","title":"Keccak.ℓ","text":"ℓ(::Type{T<:Unsigned})\n\nReturns the base-2 logarithm of the bitwidth of values of type T.\n\nExamples\n\njulia> ℓ(UInt32)\n5\n\njulia> 2^5\n32\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.rc","page":"Keccak.jl Documentation","title":"Keccak.rc","text":"rc(t)\n\nEvaluate t rounds of a linear feedback shift register and return the leading bit after the final round as specified in Algorithm 5 of FIPS-202.\n\nThis function is used for computing the round constants by round_consts.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.round_consts","page":"Keccak.jl Documentation","title":"Keccak.round_consts","text":"round_consts(::Type{T}, ::Val{nrounds}=Val(12+2ℓ(T)))\n\nCompute the Keccak round constants for lane length w corresponding to the bitwidth of T and the given number fo rounds nrounds.\n\nThe return value is a tuple of Ts containing the round constants for round indices 12+2ℓ(T)-nrounds to 12+2ℓ(T)-1 in that order. The default for nrounds results in the first round index being 0.\n\nnote: Note\nIt is valid to have nrounds>12+2ℓ(T), so that round index starts negative.\n\nExamples\n\njulia> round_consts(UInt16)\n(0x0001, 0x8082, 0x808a, 0x8000, 0x808b, 0x0001, 0x8081, 0x8009, 0x008a, 0x0088, 0x8009, 0x000a, 0x808b, 0x008b, 0x8089, 0x8003, 0x8002, 0x0080, 0x800a, 0x000a)\n\njulia> round_consts(UInt8)\n(0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(10))\n(0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(20))\n(0x02, 0x8a, 0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\n\n\n\n\n","category":"function"},{"location":"#Kᴇᴄᴄᴀᴋ-step-mappings","page":"Keccak.jl Documentation","title":"Kᴇᴄᴄᴀᴋ step mappings","text":"","category":"section"},{"location":"","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"These functions follow the specification in section 3.2 of FIPS-202.","category":"page"},{"location":"#Keccak.ι","page":"Keccak.jl Documentation","title":"Keccak.ι","text":"ι(state, RC)\n\nPerform the step mapping ι (round-dependent modification of lane[0,0]) of the Keccak algorithm and return the updated state.\n\nInstead of the round index as in FIPS-202, the corresponding round constant RC is expected as the second argument.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.θ","page":"Keccak.jl Documentation","title":"Keccak.θ","text":"θ(state)\n\nPerform the step mapping θ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.π","page":"Keccak.jl Documentation","title":"Keccak.π","text":"π(state)\n\nPerform the step mapping π (permutation of the lanes) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.χ","page":"Keccak.jl Documentation","title":"Keccak.χ","text":"χ(state)\n\nPerform the nonlinear step mapping χ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.ρ","page":"Keccak.jl Documentation","title":"Keccak.ρ","text":"ρ(state)\n\nPerform the step mapping ρ (bit rotation in each lane) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"}]
}
