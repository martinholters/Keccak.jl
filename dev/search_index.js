var documenterSearchIndex = {"docs":
[{"location":"#Keccak.jl-Documentation","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"","category":"section"},{"location":"#Keccak.keccak_p","page":"Keccak.jl Documentation","title":"Keccak.keccak_p","text":"keccak_p(state, ::Val{nrounds})\n\nThe Kᴇᴄᴄᴀᴋ-p permutation function as defined in FIPS-202, with the number of rounds given by nrounds. The input state as well as the returned updated state are 25-tuples of unsigned integers of type T. Their LSB-first serialization corresponds to the bitstrings S and S′ in FIPS-202; its length b is determined by the type T. E.g. for T==UInt64, one obtains the commonly used b = 25 ⋅ 64 = 1600.\n\nFor example, for b=800 (hence T==UInt32), S=1000...000 corresponds to state == (0x00000001, (0x00000000 for _ in 2:25)...).\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances. E.g, for state::NTuple{25,SIMD.Vec{4,UInt64}}, it holds that\n\njulia> SIMD.Vec.((keccak_p(map(s -> s[n], state)) for n in 1:4)...) == keccak_p(state)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Keccak.jl Documentation","title":"Internals","text":"","category":"section"},{"location":"#Helpers","page":"Keccak.jl Documentation","title":"Helpers","text":"","category":"section"},{"location":"#Keccak.ℓ","page":"Keccak.jl Documentation","title":"Keccak.ℓ","text":"ℓ(::Type{T<:Unsigned})\n\nReturns the base-2 logarithm of the bitwidth of values of type T.\n\nExamples\n\njulia> ℓ(UInt32)\n5\n\njulia> 2^5\n32\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.rc","page":"Keccak.jl Documentation","title":"Keccak.rc","text":"rc(t)\n\nEvaluate t rounds of a linear feedback shift register and return the leading bit after the final round as specified in Algorithm 5 of FIPS-202.\n\nThis function is used for computing the round constants by round_consts.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.round_consts","page":"Keccak.jl Documentation","title":"Keccak.round_consts","text":"round_consts(::Type{T}, ::Val{nrounds}=Val(12+2ℓ(T)))\n\nCompute the Keccak round constants for lane length w corresponding to the bitwidth of T and the given number fo rounds nrounds.\n\nThe return value is a tuple of Ts containing the round constants for round indices 12+2ℓ(T)-nrounds to 12+2ℓ(T)-1 in that order. The default for nrounds results in the first round index being 0.\n\nnote: Note\nIt is valid to have nrounds>12+2ℓ(T), so that round index starts negative.\n\nExamples\n\njulia> round_consts(UInt16)\n(0x0001, 0x8082, 0x808a, 0x8000, 0x808b, 0x0001, 0x8081, 0x8009, 0x008a, 0x0088, 0x8009, 0x000a, 0x808b, 0x008b, 0x8089, 0x8003, 0x8002, 0x0080, 0x800a, 0x000a)\n\njulia> round_consts(UInt8)\n(0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(10))\n(0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(20))\n(0x02, 0x8a, 0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\n\n\n\n\n","category":"function"},{"location":"#Kᴇᴄᴄᴀᴋ-step-mappings","page":"Keccak.jl Documentation","title":"Kᴇᴄᴄᴀᴋ step mappings","text":"","category":"section"},{"location":"","page":"Keccak.jl Documentation","title":"Keccak.jl Documentation","text":"These functions follow the specification in section 3.2 of FIPS-202.","category":"page"},{"location":"#Keccak.ι","page":"Keccak.jl Documentation","title":"Keccak.ι","text":"ι(state, RC)\n\nPerform the step mapping ι (round-dependent modification of lane[0,0]) of the Keccak algorithm and return the updated state.\n\nInstead of the round index as in FIPS-202, the corresponding round constant RC is expected as the second argument.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.θ","page":"Keccak.jl Documentation","title":"Keccak.θ","text":"θ(state)\n\nPerform the step mapping θ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.π","page":"Keccak.jl Documentation","title":"Keccak.π","text":"π(state)\n\nPerform the step mapping π (permutation of the lanes) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.χ","page":"Keccak.jl Documentation","title":"Keccak.χ","text":"χ(state)\n\nPerform the nonlinear step mapping χ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"#Keccak.ρ","page":"Keccak.jl Documentation","title":"Keccak.ρ","text":"ρ(state)\n\nPerform the step mapping ρ (bit rotation in each lane) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"}]
}
