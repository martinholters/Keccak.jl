var documenterSearchIndex = {"docs":
[{"location":"sponge/#Sponge-operations","page":"Sponge operations","title":"Sponge operations","text":"","category":"section"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"The Keccak algorithm family uses a cryptographic sponge construction. A sponge in this context is a block of data, divided in two parts of size \"rate\" and \"capacity\", respectively, combined with a transformation function and a padding rule. A sponge can \"absorb\" input data and output data can be \"squeezed\" from it. The operations may not be mixed, however. The squeezing phase has to follow the absorption phase, with no further absorbing after the first squeeze.","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"Both absorption and squeezing are specified in terms of rate-sized blocks. When absorbing a block, it is XORed with the rate part of the sponge data and the transformation function is invoked on the whole sponge data. The padding rule specifies how to cope with input data with a length not divisible by the sponge rate. Squeezing a block is done by reading the rate part from the sponge data and invoking the transformation function on the whole sponge data.","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"To ease the use, the functions absorb and squeeze allow arbitrary data sizes. The proper mapping to rate-sized blocks is handled internally. Furthermore, padding is not performed by actually modifying the input data; rather, the pad function is invoked on the sponge and immediately absorbs the padding data.","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"When using the sponge functions, it is important to note that the sponges in Keccak.jl are immutable. Hence, the sponges are not modified in-place. Instead, updated sponges are returned. Thus, computing the 256bit SHA-3 with partitioning both input and output in two blocks each could look like this:","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"julia> sponge = sha3_256_sponge();\n\njulia> sponge = absorb(sponge, 0x00:0x04); # absorb first data chunk\n\njulia> sponge = absorb(sponge, 0x05:0x09); # absorb another data chunk\n\njulia> sponge = pad(sponge); # absorb appropriate padding\n\njulia> sponge, out1 = squeeze(sponge, Val(16)); # first part of output\n\njulia> sponge, out2 = squeeze(sponge, Val(16)); # second part of output\n\njulia> (out1..., out2...)\n(0x60, 0x5a, 0x05, 0x14, 0x05, 0x91, 0x92, 0xe2, 0x6d, 0xbf, 0x06, 0xcf, 0xab, 0x86, 0xf3, 0xe9, 0xbb, 0xb9, 0xa6, 0x93, 0x63, 0xd4, 0xbe, 0x92, 0x5b, 0x22, 0x46, 0xdc, 0xd8, 0x65, 0x9a, 0x95)\n\njulia> sha3_256(0x00:0x09) # same result\n(0x60, 0x5a, 0x05, 0x14, 0x05, 0x91, 0x92, 0xe2, 0x6d, 0xbf, 0x06, 0xcf, 0xab, 0x86, 0xf3, 0xe9, 0xbb, 0xb9, 0xa6, 0x93, 0x63, 0xd4, 0xbe, 0x92, 0x5b, 0x22, 0x46, 0xdc, 0xd8, 0x65, 0x9a, 0x95)","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"The data provided to absorb can be an AbstractVector{UInt8} or a Tuple{Vararg{UInt8}}, or a String of which its codeunits will be used. If the length given to squeeze is a Val (as in the example above), the return value will be a Tuple, if given as a plain integer, it will be a Vector{UInt8}.","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"warning: Warning\nConceptually, a sponge is either in the absorption phase or the squeezing phase. In the absorption phase, only absorb or pad may be invoked, where the latter transitions the sponge to the squeezing phase. In the squeezing phase, only squeeze may be called. Thus, the only permissible order of operations on a fresh sponge is:Process the input data with zero or more calls to absorb.\nCall pad exactly once.\nProduce the output by zero or more calls to squeeze.Violating this sequence is (at present) technically possible, but the results are unspecified.","category":"page"},{"location":"sponge/#SIMD","page":"Sponge operations","title":"SIMD","text":"","category":"section"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"The sponge operations support SIMD processing if the sponge state is stored as SIMD.Vecs. Such SIMD-capable sponges can be created with sha3_224_sponge(::Val), sha3_256_sponge(::Val), sha3_384_sponge(::Val), sha3_512_sponge(::Val), shake_128_sponge(::Val), or shake_256_sponge(::Val), where the Val-parameter specifies the desired level of SIMD-parallelism. Given a sponge for N-fold parallelism, the sponge operations work as follows:","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"absorb with a single data argument absorbs the same data into all N parallel sponges.\nabsorb with N data arguments absorbs these into the respective parallel sponges. All data arguments have to be of the same length.\npad pads all N parallel sponges.\nsqueeze returns an N-tuple of the data squeezed from the respective parallel sponges.","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"For example, to compute the SHA3-256 hashes of \"message #1\",  \"message #2\",  \"message #3\", and  \"message #4\", we can do:","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"julia> sponge = sha3_256_sponge(Val(4));\n\njulia> sponge = absorb(sponge, \"message #\"); # simultaneously absorb common prefix\n\njulia> sponge = absorb(sponge, \"1\", \"2\", \"3\", \"4\"); # now with different data\n\njulia> sponge = pad(sponge);\n\njulia> squeeze(sponge, Val(32))[2]\n((0x8f, 0xf2, 0xcb, 0xa6, 0x2c, 0x19, 0x93, 0x77, 0x2a, 0x18, 0x8f, 0x8e, 0xf3, 0xa6, 0x13, 0x99, 0x15, 0x06, 0xc1, 0x48, 0x50, 0x3a, 0xd6, 0xdd, 0xbd, 0x15, 0x79, 0x09, 0x87, 0xe3, 0x61, 0x71), (0xe1, 0x44, 0x88, 0x35, 0xd8, 0x78, 0x65, 0x25, 0xa1, 0xbf, 0x5f, 0x2a, 0xfe, 0xec, 0x3b, 0x5a, 0x77, 0x4f, 0xb9, 0xa2, 0xe1, 0x91, 0x54, 0x5d, 0x1c, 0x06, 0x31, 0x94, 0x57, 0x07, 0x9c, 0x90), (0xce, 0xf9, 0x40, 0x8d, 0x2c, 0x57, 0x41, 0x91, 0x8b, 0x40, 0xc2, 0xab, 0x32, 0x42, 0xf1, 0xb5, 0xe7, 0xb2, 0x21, 0x9f, 0xbf, 0x3a, 0x3c, 0xc8, 0xe3, 0x6d, 0x0c, 0x66, 0x32, 0x00, 0x84, 0xa2), (0xf5, 0x59, 0x99, 0xcd, 0xef, 0x1a, 0x96, 0x5c, 0x80, 0x96, 0x0b, 0xe5, 0xda, 0x0b, 0xb9, 0x99, 0xa4, 0x15, 0xcb, 0x36, 0x5a, 0x8b, 0x30, 0x97, 0xfc, 0x3c, 0x5b, 0xa5, 0x59, 0xcc, 0xa0, 0xd6))\n\njulia> sha3_256(\"message #1\"), sha3_256(\"message #2\"), sha3_256(\"message #3\"), sha3_256(\"message #4\") # same result\n((0x8f, 0xf2, 0xcb, 0xa6, 0x2c, 0x19, 0x93, 0x77, 0x2a, 0x18, 0x8f, 0x8e, 0xf3, 0xa6, 0x13, 0x99, 0x15, 0x06, 0xc1, 0x48, 0x50, 0x3a, 0xd6, 0xdd, 0xbd, 0x15, 0x79, 0x09, 0x87, 0xe3, 0x61, 0x71), (0xe1, 0x44, 0x88, 0x35, 0xd8, 0x78, 0x65, 0x25, 0xa1, 0xbf, 0x5f, 0x2a, 0xfe, 0xec, 0x3b, 0x5a, 0x77, 0x4f, 0xb9, 0xa2, 0xe1, 0x91, 0x54, 0x5d, 0x1c, 0x06, 0x31, 0x94, 0x57, 0x07, 0x9c, 0x90), (0xce, 0xf9, 0x40, 0x8d, 0x2c, 0x57, 0x41, 0x91, 0x8b, 0x40, 0xc2, 0xab, 0x32, 0x42, 0xf1, 0xb5, 0xe7, 0xb2, 0x21, 0x9f, 0xbf, 0x3a, 0x3c, 0xc8, 0xe3, 0x6d, 0x0c, 0x66, 0x32, 0x00, 0x84, 0xa2), (0xf5, 0x59, 0x99, 0xcd, 0xef, 0x1a, 0x96, 0x5c, 0x80, 0x96, 0x0b, 0xe5, 0xda, 0x0b, 0xb9, 0x99, 0xa4, 0x15, 0xcb, 0x36, 0x5a, 0x8b, 0x30, 0x97, 0xfc, 0x3c, 0x5b, 0xa5, 0x59, 0xcc, 0xa0, 0xd6))","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"For convenience, sha3_256 accepts multiple arguments (of the same length) directly, so the above can be written as","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"julia> sha3_256(\"message #1\", \"message #2\", \"message #3\", \"message #4\")\n((0x8f, 0xf2, 0xcb, 0xa6, 0x2c, 0x19, 0x93, 0x77, 0x2a, 0x18, 0x8f, 0x8e, 0xf3, 0xa6, 0x13, 0x99, 0x15, 0x06, 0xc1, 0x48, 0x50, 0x3a, 0xd6, 0xdd, 0xbd, 0x15, 0x79, 0x09, 0x87, 0xe3, 0x61, 0x71), (0xe1, 0x44, 0x88, 0x35, 0xd8, 0x78, 0x65, 0x25, 0xa1, 0xbf, 0x5f, 0x2a, 0xfe, 0xec, 0x3b, 0x5a, 0x77, 0x4f, 0xb9, 0xa2, 0xe1, 0x91, 0x54, 0x5d, 0x1c, 0x06, 0x31, 0x94, 0x57, 0x07, 0x9c, 0x90), (0xce, 0xf9, 0x40, 0x8d, 0x2c, 0x57, 0x41, 0x91, 0x8b, 0x40, 0xc2, 0xab, 0x32, 0x42, 0xf1, 0xb5, 0xe7, 0xb2, 0x21, 0x9f, 0xbf, 0x3a, 0x3c, 0xc8, 0xe3, 0x6d, 0x0c, 0x66, 0x32, 0x00, 0x84, 0xa2), (0xf5, 0x59, 0x99, 0xcd, 0xef, 0x1a, 0x96, 0x5c, 0x80, 0x96, 0x0b, 0xe5, 0xda, 0x0b, 0xb9, 0x99, 0xa4, 0x15, 0xcb, 0x36, 0x5a, 0x8b, 0x30, 0x97, 0xfc, 0x3c, 0x5b, 0xa5, 0x59, 0xcc, 0xa0, 0xd6))","category":"page"},{"location":"sponge/","page":"Sponge operations","title":"Sponge operations","text":"In the same fashion, shake_128 and shake_256 can also be applied to multiple data arguments.","category":"page"},{"location":"fips-202/#SHA-3-(and-SHAKE)","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"","category":"section"},{"location":"fips-202/#SHA-3","page":"SHA-3 (and SHAKE)","title":"SHA-3","text":"","category":"section"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"The most commonly used functionality contained in Keccak.jl probably is computation of digests according to the Secure Hash Algorithm-3 (SHA-3) as specified in NIST FIPS-202. SHA-3 is a family of hashing functions differing in the length of the generated digits, offering 224 bits, 256 bits, 384 bits, or 512 bits of output length. These map to the functions sha3_224, sha3_256, sha3_384, and sha3_512, respectively. In the following, examples will be limited to the 256 bits version; the other lengths work similarly.","category":"page"},{"location":"fips-202/#Basic-usage","page":"SHA-3 (and SHAKE)","title":"Basic usage","text":"","category":"section"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"We start with a very basic example:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"julia> using Keccak: sha3_256\n\njulia> sha3_256(\"a message to compute the digest of\")\n(0xfa, 0x24, 0x49, 0x91, 0xa1, 0x94, 0x44, 0x1e, 0xd6, 0xa8, 0x34, 0x19, 0xd2, 0x00, 0x44, 0x12, 0x15, 0xa9, 0x7c, 0x49, 0xc6, 0xcf, 0x5e, 0x28, 0x7f, 0x75, 0x75, 0x45, 0x73, 0x6d, 0x25, 0x23)","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"As can be seen, the output is a tuple of UInt8s, namely 32 of them for a total of the required 32⋅8=256 bits. The interface is very similar to that of the SHA standard library:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"julia> using SHA: sha3_256\n\njulia> sha3_256(\"a message to compute the digest of\")\n32-element Vector{UInt8}:\n 0xfa\n 0x24\n 0x49\n 0x91\n 0xa1\n 0x94\n 0x44\n 0x1e\n 0xd6\n 0xa8\n    ⋮\n 0x28\n 0x7f\n 0x75\n 0x75\n 0x45\n 0x73\n 0x6d\n 0x25\n 0x23","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"The SHA standard library produces the same output, of course, but stores it in a Vector.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"note: Note\nBut SHA and Keccak export functions of the same name, so care must be taken when importing both of them to prevent name clashes. It is recommended to import only those symbols actually used, e.g. using Keccak: sha3_256 instead of using Keccak.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Apart from the return type, there are two noteworthy differences between the SHA and the Keccak implementations:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Keccak only allows AbstractVector{UInt8} und Tuple{Vararg{UInt8}} input in addition to the String input demonstrated above, while SHA also supports IO to hash all data coming from an IO object (e.g. a file).\nPerformance:\nusing Chairmarks: @b\nimport Keccak, SHA\n@b rand(UInt8, 1_000_000) Keccak.sha3_256, SHA.sha3_256\n\n# output\n\n(1.803 ms, 6.684 ms (9 allocs: 720 bytes))\nThe Keccak implementation is faster and avoids allocations. (Comparison was done using Julia v1.12.0-rc1).","category":"page"},{"location":"fips-202/#Chunked-input-(and-output)","page":"SHA-3 (and SHAKE)","title":"Chunked input (and output)","text":"","category":"section"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"When e.g. needing to hash a large file, it may be inappropriate to read it into memory as a whole. Rather, one would like to process the data in reasonably-sized chunks. This is possible using the sponge-based interface of Keccak. (The term \"sponge\" stems from the algorithm family underlying SHA-3 – Keccak – using a so-called cryptographic sponge construction.)","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Using the sponge-based interface entails the following steps:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Obtain a suitable sponge with e.g. sha3_256_sponge.\nProcess the input data with zero or more calls to absorb. (Zero calls correspond to an empty input.)\nCall pad exactly once.\nProduce the output by one or more calls to squeeze. (Zero calls are technically permitted, too, but pointless.)","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"warning: Warning\nAt present, adhering to above sequence is not enforced, but the behavior for any other sequence of absorb, pad and squeeze invocations is unspecified.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"An important feature of the sponges used by Keccak is that they are immutable. Therefore, none of the operations above mutate the given sponge in-place; rather, they return an updated sponge.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"The following example shows both chunked input (multiple calls to absorb) as well as chunked output (multiple calls to squeeze), although the latter is certainly less useful is this context:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"julia> sponge = sha3_256_sponge();\n\njulia> sponge = absorb(sponge, 0x00:0x04); # absorb first data chunk\n\njulia> sponge = absorb(sponge, 0x05:0x09); # absorb another data chunk\n\njulia> sponge = pad(sponge); # absorb appropriate padding\n\njulia> sponge, out1 = squeeze(sponge, Val(16)); # first part of output\n\njulia> sponge, out2 = squeeze(sponge, Val(16)); # second part of output\n\njulia> (out1..., out2...) == sha3_256(0x00:0x09) # same result\ntrue","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Note that the desired output length of squeeze has to be given in bytes. If the number is passed directly instead of wrapped in a Val, the output will be a Vector{UInt8} instead of a tuple.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"note: Note\nSqueezing fewer or more bytes from the sponge than the standard demands is perfectly valid technically, but obviously not standard-compliant. And as the output length matches the security strength, squeezing more bytes will not produce a more secure digest. An application scenario where squeezing more bytes makes sense is to use the hashing function as a pseudo-random function generator. If this is your aim, consider SHAKE, cSHAKE, or the extensible output variants of KMAC, TupleHash, or ParallelHash.","category":"page"},{"location":"fips-202/#SHAKE","page":"SHA-3 (and SHAKE)","title":"SHAKE","text":"","category":"section"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"The NIST FIPS-202 standard specifies an extensible-output variant of SHA-3, called SHAKE, for security strengths 128 bits and 256 bits. These are available in Keccak as shake_128 and shake_256, respectively.","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Similar to the SHA-3 functions, one can directly compute a SHAKE-digest from input data, but has to pass the desired output length:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"julia> msg = \"a message to compute the digest of\";\n\njulia> shake_128(msg, 10) # returns a vector\n10-element Vector{UInt8}:\n 0xd4\n 0xa7\n 0x25\n 0x77\n 0xde\n 0x29\n 0x05\n 0x20\n 0x9b\n 0x35\n\njulia> shake_128(msg, Val(10)) # returns a tuple\n(0xd4, 0xa7, 0x25, 0x77, 0xde, 0x29, 0x05, 0x20, 0x9b, 0x35)\n\njulia> shake_128(msg, Val(15)) # longer output, first 10 bytes equal\n(0xd4, 0xa7, 0x25, 0x77, 0xde, 0x29, 0x05, 0x20, 0x9b, 0x35, 0x64, 0x68, 0x9a, 0x96, 0xad)","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"Chunked input and output is possible in the same way as for SHA-3 (see above), replacing sha3_256_sponge with shake_128_sponge (or shake_256_sponge). For convenience, one can also obtain a sponge ready for squeezing by calling shake_128(data) without specifying the output length:","category":"page"},{"location":"fips-202/","page":"SHA-3 (and SHAKE)","title":"SHA-3 (and SHAKE)","text":"julia> msg = \"a message to compute the digest of\";\n\njulia> sponge = shake_128(msg);\n\njulia> sponge, out1 = squeeze(sponge, Val(10));\n\njulia> out1 # as above\n(0xd4, 0xa7, 0x25, 0x77, 0xde, 0x29, 0x05, 0x20, 0x9b, 0x35)\n\njulia> sponge, out2 = squeeze(sponge, Val(5));\n\njulia> out2 # last five bytes of the length-15 example above\n(0x64, 0x68, 0x9a, 0x96, 0xad)","category":"page"},{"location":"keccak/#Keccak-based-sponge-construction","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"","category":"section"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"The Keccak algorithm family as defined in NIST FIPS-202 is made up of a mapping function (Kᴇᴄᴄᴀᴋ-p) and a padding rule wrapped in a cryptographic sponge. All Keccak-based hashing algorithms are based on this construction.","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"The permutation function Kᴇᴄᴄᴀᴋ-p[b,nᵣ] is defined on a bit-string of length b=25⋅2ˡ for l ∈ {0, …, 6}. This bit-string is treated as a sequence of 25 lanes of length 2ˡ each, and the corresponding  Keccak.jl implementation keccak_p expects an NTuple{25} of unsigned integers holding those lanes. Given the available unsigned integer types, it follows that the implementation does not support l<3. As all relevant uses of Keccak set l=6, this restriction does not pose a limitation in practice. As second argument to keccak_p, the desired number of rounds nᵣ can be specified (as a Val), with the default of nᵣ=12+2l resulting in the permutation function Kᴇᴄᴄᴀᴋ-f[b].","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"For example, applying Kᴇᴄᴄᴀᴋ-f[200] to the all-zero state would look as follows:","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"julia> keccak_p(ntuple(_ -> zero(UInt8), Val(25)))\n(0x3c, 0x28, 0x26, 0x84, 0x1c, 0xb3, 0x5c, 0x17, 0x1e, 0xaa, 0xe9, 0xb8, 0x11, 0x13, 0x4c, 0xea, 0xa3, 0x85, 0x2c, 0x69, 0xd2, 0xc5, 0xab, 0xaf, 0xea)","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"To avoid repeated anonymous functions s -> keccak_p(s, Val(nr)) fixing the number of rounds, a wrapper KeccakP{nrounds}() is provided with the same effect.","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"If the input to keccak_p is an NTuple{25} of SIMD.Vecs, it is treated as multiple states is parallel. That is","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"state1 = Tuple(rand(UInt64, 25))\nstate2 = Tuple(rand(UInt64, 25))\nsimdstate = SIMD.Vec.(state1, state2) # now an NTuple{25, SIMD.Vec{2, UInt64}}\nSIMD.Vec.(keccak_p(state1), keccak_p(state2)) == keccak_p(simdstate)\n\n# output\n\ntrue","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"Keccak employs the \"pad10*1\" padding rule, i.e. a 1-bit, an appropriate number of 0-bits, and another 1-bit are appended to the input to obtain a total length that is a multiple of the sponge rate. Typical uses like SHA-3, SHAKE, or cSHAKE insert additional fixed bits immediately before the padding to achieve domain separation. This padding with optional domain separation is encapsulated in KeccakPad, see there for a discussion how to specify the domain separation bits. Instances of KeccakPad are applied to sponges rather than input data and directly absorb the padding for performance reasons. They are used by pad internally:","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"sha3pad = KeccakPad(0b110) # domain separation 01, first padding 1-bit, but LSB-first, hence reversed\nsponge = sha3_256_sponge()\nsponge = absorb(sponge, rand(UInt8, 23))\npad(sponge) == sha3pad(sponge)\n\n# output\n\ntrue","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"Sponges with a combination of KeccakP as transformation function and KeccakPad as padding rule are defined by KeccakSponge. A KeccakSponge is instantiated by calling KeccakSponge{R,T,nrounds}(pad) where T is the storage type of the lanes (i.e. unsigned integers of 2ˡ bits) or SIMD.Vecs thereof, R is the sponge rate in number of lanes, nrounds is the number of rounds to use in Kᴇᴄᴄᴀᴋ-p (defaulting to 12+2l if omitted) and pad is an instance of KeccakPad to use for padding. For example, SHA-3 uses l=6, so T=UInt64, and a rate of 1600-2d bits where d is the digest length. For a digest length of 256, that gives 1088 bits corresponding to 1088/64=17 lanes. Thus sha3_256_sponge() is equal to KeccakSponge{17,UInt64}(KeccakPad(0b110)):","category":"page"},{"location":"keccak/","page":"Keccak-based sponge construction","title":"Keccak-based sponge construction","text":"julia> data = \"a message to compute the digest of\";\n\njulia> digest = squeeze(pad(absorb(KeccakSponge{17,UInt64}(KeccakPad(0b110)), data)), Val(32))[2]\n(0xfa, 0x24, 0x49, 0x91, 0xa1, 0x94, 0x44, 0x1e, 0xd6, 0xa8, 0x34, 0x19, 0xd2, 0x00, 0x44, 0x12, 0x15, 0xa9, 0x7c, 0x49, 0xc6, 0xcf, 0x5e, 0x28, 0x7f, 0x75, 0x75, 0x45, 0x73, 0x6d, 0x25, 0x23)\n\njulia> digest == sha3_256(data)\ntrue","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#sha-3-reference","page":"Reference","title":"SHA-3","text":"","category":"section"},{"location":"reference/#Keccak.sha3_224","page":"Reference","title":"Keccak.sha3_224","text":"sha3_224(data)\n\nComputes the SHA3-224 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a 28-tuple of UInt8s.\n\nExamples\n\njulia> sha3_224(fill(0xa3, 200))\n(0x93, 0x76, 0x81, 0x6a, 0xba, 0x50, 0x3f, 0x72, 0xf9, 0x6c, 0xe7, 0xeb, 0x65, 0xac, 0x09, 0x5d, 0xee, 0xe3, 0xbe, 0x4b, 0xf9, 0xbb, 0xc2, 0xa1, 0xcb, 0x7e, 0x11, 0xe0)\n\n\n\n\n\nsha3_224(data1, ..., dataN)\n\nComputes the SHA3-224 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 28-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_256","page":"Reference","title":"Keccak.sha3_256","text":"sha3_256(data)\n\nComputes the SHA3-256 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a 32-tuple of UInt8s.\n\nExamples\n\njulia> sha3_256(fill(0xa3, 200))\n(0x79, 0xf3, 0x8a, 0xde, 0xc5, 0xc2, 0x03, 0x07, 0xa9, 0x8e, 0xf7, 0x6e, 0x83, 0x24, 0xaf, 0xbf, 0xd4, 0x6c, 0xfd, 0x81, 0xb2, 0x2e, 0x39, 0x73, 0xc6, 0x5f, 0xa1, 0xbd, 0x9d, 0xe3, 0x17, 0x87)\n\n\n\n\n\nsha3_256(data1, ..., dataN)\n\nComputes the SHA3-256 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 32-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_384","page":"Reference","title":"Keccak.sha3_384","text":"sha3_384(data)\n\nComputes the SHA3-384 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a 48-tuple of UInt8s.\n\nExamples\n\njulia> sha3_384(fill(0xa3, 200))\n(0x18, 0x81, 0xde, 0x2c, 0xa7, 0xe4, 0x1e, 0xf9, 0x5d, 0xc4, 0x73, 0x2b, 0x8f, 0x5f, 0x00, 0x2b, 0x18, 0x9c, 0xc1, 0xe4, 0x2b, 0x74, 0x16, 0x8e, 0xd1, 0x73, 0x26, 0x49, 0xce, 0x1d, 0xbc, 0xdd, 0x76, 0x19, 0x7a, 0x31, 0xfd, 0x55, 0xee, 0x98, 0x9f, 0x2d, 0x70, 0x50, 0xdd, 0x47, 0x3e, 0x8f)\n\n\n\n\n\nsha3_384(data1, ..., dataN)\n\nComputes the SHA3-384 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 48-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_512","page":"Reference","title":"Keccak.sha3_512","text":"sha3_512(data)\n\nComputes the SHA3-512 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a 64-tuple of UInt8s.\n\nExamples\n\njulia> sha3_512(fill(0xa3, 200))\n(0xe7, 0x6d, 0xfa, 0xd2, 0x20, 0x84, 0xa8, 0xb1, 0x46, 0x7f, 0xcf, 0x2f, 0xfa, 0x58, 0x36, 0x1b, 0xec, 0x76, 0x28, 0xed, 0xf5, 0xf3, 0xfd, 0xc0, 0xe4, 0x80, 0x5d, 0xc4, 0x8c, 0xae, 0xec, 0xa8, 0x1b, 0x7c, 0x13, 0xc3, 0x0a, 0xdf, 0x52, 0xa3, 0x65, 0x95, 0x84, 0x73, 0x9a, 0x2d, 0xf4, 0x6b, 0xe5, 0x89, 0xc5, 0x1c, 0xa1, 0xa4, 0xa8, 0x41, 0x6d, 0xf6, 0x54, 0x5a, 0x1c, 0xe8, 0xba, 0x00)\n\n\n\n\n\nsha3_512(data1, ..., dataN)\n\nComputes the SHA3-512 hashes of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The hashes are returned as an N-tuple of 64-tuples of UInt8s.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_224_sponge","page":"Reference","title":"Keccak.sha3_224_sponge","text":"sha3_224_sponge()\n\nReturns a sponge suitable for SHA3-224 computation.\n\n\n\n\n\nsha3_224_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-224 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_256_sponge","page":"Reference","title":"Keccak.sha3_256_sponge","text":"sha3_256_sponge()\n\nReturns a sponge suitable for SHA3-256 computation.\n\n\n\n\n\nsha3_256_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-256 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_384_sponge","page":"Reference","title":"Keccak.sha3_384_sponge","text":"sha3_384_sponge()\n\nReturns a sponge suitable for SHA3-384 computation.\n\n\n\n\n\nsha3_384_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-384 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.sha3_512_sponge","page":"Reference","title":"Keccak.sha3_512_sponge","text":"sha3_512_sponge()\n\nReturns a sponge suitable for SHA3-512 computation.\n\n\n\n\n\nsha3_512_sponge(::Val{N})\n\nReturns a sponge suitable for SHA3-512 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#shake-reference","page":"Reference","title":"SHAKE","text":"","category":"section"},{"location":"reference/#Keccak.shake_128","page":"Reference","title":"Keccak.shake_128","text":"shake_128(data)\n\nReturns a SHAKE-128 sponge with data absorbed, ready to squeeze from.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). Appropriate padding is applied by shake_128.\n\n\n\n\n\nshake_128(data, len)\n\nComputes the SHAKE-128 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExamples\n\njulia> shake_128(fill(0xa3, 200), Val(20))\n(0x13, 0x1a, 0xb8, 0xd2, 0xb5, 0x94, 0x94, 0x6b, 0x9c, 0x81, 0x33, 0x3f, 0x9b, 0xb6, 0xe0, 0xce, 0x75, 0xc3, 0xb9, 0x31)\n\n\n\n\n\nshake_128(data1, ..., dataN)\n\nAbsorbs data1, ..., dataN (for N >= 2) into a new N-fold-SIMD SHAKE-128 sponge and pads it.\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The data is absorbed into a fresh (SIMD) SHAKE-128 sponge and padding is applied.\n\nThe returned sponge is ready for being squeezed.\n\n\n\n\n\nshake_128(data1, ..., dataN, len)\n\nComputes the SHAKE-128 hash of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation.\n\nAn N-tuple of the individual hashes of the desired length is returned. The hashes are tuples of UInt8s if len is a Val, Vector{UInt8}s otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.shake_256","page":"Reference","title":"Keccak.shake_256","text":"shake_256(data)\n\nReturns a SHAKE-256 sponge with data absorbed, ready to squeeze from.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). Appropriate padding is applied by shake_256.\n\n\n\n\n\nshake_256(data, len)\n\nComputes the SHAKE-256 hash of data.\n\nThe provided data must be an AbstractVector or a Tuple of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExamples\n\njulia> shake_256(fill(0xa3, 200), Val(20))\n(0xcd, 0x8a, 0x92, 0x0e, 0xd1, 0x41, 0xaa, 0x04, 0x07, 0xa2, 0x2d, 0x59, 0x28, 0x86, 0x52, 0xe9, 0xd9, 0xf1, 0xa7, 0xee)\n\n\n\n\n\nshake_256(data1, ..., dataN)\n\nAbsorbs data1, ..., dataN (for N >= 2) into a new N-fold-SIMD SHAKE-256 sponge and pads it.\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation. The data is absorbed into a fresh (SIMD) SHAKE-256 sponge and padding is applied.\n\nThe returned sponge is ready for being squeezed.\n\n\n\n\n\nshake_256(data1, ..., dataN, len)\n\nComputes the SHAKE-256 hash of data1, ..., dataN (for N >= 2).\n\nThe provided data must be AbstractVectors or Tuples of UInt8s or Strings, and they all must have the same length in bytes (using codeunits for Strings) as SIMD is used to speed up the hash computation.\n\nAn N-tuple of the individual hashes of the desired length is returned. The hashes are tuples of UInt8s if len is a Val, Vector{UInt8}s otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.shake_128_sponge","page":"Reference","title":"Keccak.shake_128_sponge","text":"shake_128_sponge()\n\nReturns a sponge suitable for SHAKE-128 computation.\n\n\n\n\n\nshake_128_sponge(::Val{N})\n\nReturns a sponge suitable for SHAKE-128 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.shake_256_sponge","page":"Reference","title":"Keccak.shake_256_sponge","text":"shake_256_sponge()\n\nReturns a sponge suitable for SHAKE-256 computation.\n\n\n\n\n\nshake_256_sponge(::Val{N})\n\nReturns a sponge suitable for SHAKE-256 computation using N-fold SIMD, i.e. a sponge with SIMD.Vec{N} contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#cshake-reference","page":"Reference","title":"cSHAKE","text":"","category":"section"},{"location":"reference/#Keccak.cshake_128","page":"Reference","title":"Keccak.cshake_128","text":"cshake_128(data, N=(), S=())\n\nReturns a cSHAKE-128 sponge for function-name N and customization S with data absorbed, ready to squeeze from.\n\nThe provided data, N, and S must be AbstractVectors or a Tuples of UInt8s, or a String (which is converted to bytes by codeunits). Appropriate padding is applied by cshake_128.\n\n\n\n\n\ncshake_128(data, len, N=(), S=())\n\nComputes the cSHAKE-128 hash of data for function-name N and customization S.\n\nThe provided data, N, and S must be AbstractVectors or a Tuples of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.cshake_256","page":"Reference","title":"Keccak.cshake_256","text":"cshake_256(data, N=(), S=())\n\nReturns a cSHAKE-256 sponge for function-name N and customization S with data absorbed, ready to squeeze from.\n\nThe provided data, N, and S must be AbstractVectors or a Tuples of UInt8s, or a String (which is converted to bytes by codeunits). Appropriate padding is applied by cshake_256.\n\n\n\n\n\ncshake_256(data, len, N=(), S=())\n\nComputes the cSHAKE-256 hash of data for function-name N and customization S.\n\nThe provided data, N, and S must be AbstractVectors or a Tuples of UInt8s, or a String (which is converted to bytes by codeunits). The hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.cshake_128_sponge","page":"Reference","title":"Keccak.cshake_128_sponge","text":"cshake_128_sponge(N=(), S=())\n\nReturns a sponge suitable for cSHAKE-128 computation for function-name N and customization S. Both N and S can be Tuples or AbstractVectors of UInt8, or String (of which their codeunits are used) and default to (), i.e. the empty string.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.cshake_256_sponge","page":"Reference","title":"Keccak.cshake_256_sponge","text":"cshake_256_sponge(N=(), S=())\n\nReturns a sponge suitable for cSHAKE-256 computation for function-name N and customization S. Both N and S can be Tuples or AbstractVectors of UInt8, or String (of which their codeunits are used) and default to (), i.e. the empty string.\n\n\n\n\n\n","category":"function"},{"location":"reference/#kmac-reference","page":"Reference","title":"KMAC","text":"","category":"section"},{"location":"reference/#Keccak.kmac_128","page":"Reference","title":"Keccak.kmac_128","text":"kmac_128(K, data, len, S=())\n\nComputes the Kᴇᴄᴄᴀᴋ Message Authentication Code (KMAC128) of data using key K, output length len (in bytes) and (optional) customization string S.\n\nIf len is provided as a Val, the KMAC is returned as a Tuple, otherwise as a Vector.\n\nnote: Note\nThe output length is included in the hash, so changing it will not only produce more or fewer bytes of the same hash, but rather change the hash completely. See kmac_xof_128 for an alternative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.kmac_256","page":"Reference","title":"Keccak.kmac_256","text":"kmac_256(K, data, len, S=())\n\nComputes the Kᴇᴄᴄᴀᴋ Message Authentication Code (KMAC256) of data using key K, output length len (in bytes) and (optional) customization string S.\n\nIf len is provided as a Val, the KMAC is returned as a Tuple, otherwise as a Vector.\n\nnote: Note\nThe output length is included in the hash, so changing it will not only produce more or fewer bytes of the same hash, but rather change the hash completely. See kmac_xof_256 for an alternative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.kmac_xof_128","page":"Reference","title":"Keccak.kmac_xof_128","text":"kmac_xof_128(K, data, S=())\n\nCreates a sponge for the extensible output Kᴇᴄᴄᴀᴋ Message Authentication Code (KMACXOF128) of data using key K and (optional) customization string S.\n\nThe sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\nkmac_xof_128(K, data, len, S=())\n\nComputes the extensible output Kᴇᴄᴄᴀᴋ Message Authentication Code (KMACXOF128) of data using key K, output length len (in bytes) and (optional) customization string S.\n\nIf len is provided as a Val, the KMAC is returned as a Tuple, otherwise as a Vector. Contrary to kmac_128, the output length is not included in the hash, so the result for a smaller len is the prefix of the result for a larger len.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.kmac_xof_256","page":"Reference","title":"Keccak.kmac_xof_256","text":"kmac_xof_256(K, data, S=())\n\nCreates a sponge for the extensible output Kᴇᴄᴄᴀᴋ Message Authentication Code (KMACXOF256) of data using key K and (optional) customization string S.\n\nThe sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\nkmac_xof_256(K, data, len, S=())\n\nComputes the extensible output Kᴇᴄᴄᴀᴋ Message Authentication Code (KMACXOF256) of data using key K, output length len (in bytes) and (optional) customization string S.\n\nIf len is provided as a Val, the KMAC is returned as a Tuple, otherwise as a Vector. Contrary to kmac_256, the output length is not included in the hash, so the result for a smaller len is the prefix of the result for a larger len.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.kmac_128_sponge","page":"Reference","title":"Keccak.kmac_128_sponge","text":"kmac_128_sponge(K, len=0, S=())\n\nCreates a sponge for computing the Kᴇᴄᴄᴀᴋ Message Authentication Code (KMAC128) using key K and (optional) customization string S. The length len (in bytes) is absorbed into the sponge, so the output depends on it, though it does not prescribe the amount of data to squeeze. However, to compute a standard-conforming KAMC128, the lengths must match, or len must be set to zero to indicate an arbitrary output length KMACXOF128.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.kmac_256_sponge","page":"Reference","title":"Keccak.kmac_256_sponge","text":"kmac_256_sponge(K, len=0, S=())\n\nCreates a sponge for computing the Kᴇᴄᴄᴀᴋ Message Authentication Code (KMAC256) using key K and (optional) customization string S. The length len (in bytes) is absorbed into the sponge, so the output depends on it, though it does not prescribe the amount of data to squeeze. However, to compute a standard-conforming KAMC256, the lengths must match, or len must be set to zero to indicate an arbitrary output length KMACXOF256.\n\n\n\n\n\n","category":"function"},{"location":"reference/#tuplehash-reference","page":"Reference","title":"TupleHash","text":"","category":"section"},{"location":"reference/#Keccak.tuplehash_128","page":"Reference","title":"Keccak.tuplehash_128","text":"tuplehash_128(data, len, S=())\n\nComputes the TupleHash128 of length len from data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExample\n\njulia> tuplehash_128([\"abcd\", \"ef\"], Val(16))\n(0x9c, 0x68, 0x5d, 0x62, 0x70, 0xab, 0x35, 0x59, 0xcb, 0x34, 0x60, 0x07, 0x8b, 0xb2, 0x30, 0x2b)\n\njulia> tuplehash_128([\"abc\", \"def\"], Val(16)) # different partitioning of same data -> different hash\n(0xe9, 0xee, 0x78, 0x85, 0x9a, 0x46, 0x37, 0x69, 0xc3, 0xaa, 0x05, 0xcb, 0x3c, 0x41, 0x81, 0xa3)\n\njulia> tuplehash_128([\"abc\", \"def\"], Val(12)) # different output length -> different hash\n(0x20, 0x7e, 0x63, 0xbb, 0x5c, 0xae, 0xb1, 0x5e, 0x6e, 0xd9, 0x67, 0xf8)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.tuplehash_256","page":"Reference","title":"Keccak.tuplehash_256","text":"tuplehash_256(data, len, S=())\n\nComputes the TupleHash256 of length len from data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nExample\n\njulia> tuplehash_256([\"abcd\", \"ef\"], Val(16))\n(0xbd, 0x47, 0x29, 0xaa, 0x8b, 0x85, 0x0d, 0x9d, 0xf9, 0x1f, 0x7d, 0xf3, 0x05, 0x95, 0xad, 0x67)\n\njulia> tuplehash_256([\"abc\", \"def\"], Val(16)) # different partitioning of same data -> different hash\n(0x6c, 0x9d, 0xe6, 0x73, 0x81, 0x5a, 0xf6, 0x06, 0xf6, 0xee, 0x8f, 0x92, 0x15, 0x6d, 0x35, 0x9a)\n\njulia> tuplehash_256([\"abc\", \"def\"], Val(12)) # different output length -> different hash\n(0x0b, 0x9e, 0x3c, 0x8c, 0x3b, 0x40, 0x06, 0x93, 0xd6, 0x5f, 0xda, 0xd7)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.tuplehash_xof_128","page":"Reference","title":"Keccak.tuplehash_xof_128","text":"tuplehash_xof_128(data, S=())\n\nCreates a sponge for the arbitrary-length output TupleHash128 for data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe returned sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\ntuplehash_xof_128(data, len, S=())\n\nComputes the arbitrary-length output TupleHash128 of length len from data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nThe difference to tuplehash_128 is that the len is not itself hashed.\n\nExample\n\njulia> tuplehash_xof_128([\"abc\", \"def\"], Val(16))\n(0xf0, 0xde, 0xf4, 0x88, 0x9a, 0xed, 0x8e, 0x8f, 0x77, 0xc0, 0xef, 0xf1, 0x60, 0xa3, 0x80, 0x54)\n\njulia> tuplehash_xof_128([\"abc\", \"def\"], Val(12)) # prefix of the above\n(0xf0, 0xde, 0xf4, 0x88, 0x9a, 0xed, 0x8e, 0x8f, 0x77, 0xc0, 0xef, 0xf1)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.tuplehash_xof_256","page":"Reference","title":"Keccak.tuplehash_xof_256","text":"tuplehash_xof_256(data, S=())\n\nCreates a sponge for the arbitrary-length output TupleHash256 for data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe returned sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\ntuplehash_xof_256(data, len, S=())\n\nComputes the arbitrary-length output TupleHash256 of length len from data and the optional customization string S.\n\nThe data can be any iterable object that produces Tuples or AbstractVectors of UInt8s or Strings. (I.e. contrary to what the name suggests, data being a Tuple is just one option).\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nThe difference to tuplehash_256 is that the len is not itself hashed.\n\nExample\n\njulia> tuplehash_xof_256([\"abc\", \"def\"], Val(16))\n(0xc0, 0xaf, 0xa4, 0xf2, 0xfa, 0x02, 0x28, 0x60, 0xa9, 0x57, 0x6d, 0x99, 0x43, 0x78, 0xae, 0x86)\n\njulia> tuplehash_xof_256([\"abc\", \"def\"], Val(12)) # prefix of the above\n(0xc0, 0xaf, 0xa4, 0xf2, 0xfa, 0x02, 0x28, 0x60, 0xa9, 0x57, 0x6d, 0x99)\n\n\n\n\n\n","category":"function"},{"location":"reference/#parallelhash-reference","page":"Reference","title":"ParallelHash","text":"","category":"section"},{"location":"reference/#Keccak.parallelhash_128","page":"Reference","title":"Keccak.parallelhash_128","text":"parallelhash_128(data, blocksize, len, S=(); threaded=true)\n\nComputes the ParallelHash128 of length len with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.parallelhash_256","page":"Reference","title":"Keccak.parallelhash_256","text":"parallelhash_256(data, blocksize, len, S=(); threaded=true)\n\nComputes the ParallelHash256 of length len with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.parallelhash_xof_128","page":"Reference","title":"Keccak.parallelhash_xof_128","text":"parallelhash_xof_128(data, blocksize, S=(); threaded=true)\n\nCreates a sponge for the arbitrary-length output ParallelHashXOF128 with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe returned sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\nparallelhash_xof_128(data, blocksize, len, S=(); threaded=true)\n\nComputes the arbitrary-length output ParallelHashXOF128 of length len with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nThe difference to parallelhash_128 is that the len is not itself hashed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.parallelhash_xof_256","page":"Reference","title":"Keccak.parallelhash_xof_256","text":"parallelhash_xof_256(data, blocksize, S=(); threaded=true)\n\nCreates a sponge for the arbitrary-length output ParallelHashXOF256 with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe returned sponge is ready to squeeze output of the desired length from.\n\n\n\n\n\nparallelhash_xof_256(data, blocksize, len, S=(); threaded=true)\n\nComputes the arbitrary-length output ParallelHashXOF256 of length len with block size blocksize from data and the optional customization string S.\n\nThe data can be a AbstractVector of UInt8s or aString. (Contrary to the other hashing functions, Tuples are not supported). It is processed in chunks of size blocksize, using SIMD and (unless disabled by passing threaded=false) multi-threading to parallelize the computation. Note that changing blocksize not only affects performance, but also the result, so it is not purely an optimization.\n\nThe hash is returned as a tuple of UInt8s if len is a Val, as a Vector{UInt8} otherwise.\n\nThe difference to parallelhash_256 is that the len is not itself hashed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#sponge-reference","page":"Reference","title":"Sponge Operations","text":"","category":"section"},{"location":"reference/#Keccak.absorb","page":"Reference","title":"Keccak.absorb","text":"absorb(sponge::Sponge, data::AbsorbableData)\n\nAbsorbs the provided data into the sponge and returns the updated sponge.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\nIf the sponge holds SIMD.Vecs, the same data is used for every data path.\n\n\n\n\n\nabsorb(sponge::Sponge, data1, ..., dataN)\n\nAbsorbs the provided data into the SIMD sponge and returns the updated sponge.\n\nThe sponge has to hold SIMD.Vec{N}s, matching the number of provided data parameters, and their lengths must be equal, i.e. length(data1) == ... == length(dataN) has to hold.\n\nThe provided data does not have to have a length that is a multiple of the sponge rate. However, before the first squeeze, appropriate padding should be performed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.pad","page":"Reference","title":"Keccak.pad","text":"pad(sponge)\n\nApplies padding to sponge and returns the updated sponge.\n\nMust be called after the last call to absorb and before the first call to squeeze.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.squeeze","page":"Reference","title":"Keccak.squeeze","text":"sponge′, data = squeeze(sponge, len)\n\nSqueezes len bytes from the sponge and returns the updated sponge and the obtained data.\n\nIf len is a Val, the data is returned as a tuple, otherwise as a Vector{UInt8}.\n\nIf the sponge holds SIMD.Vec{N}s, the returned data is an N-tuple of the data squeezed form the respective data paths.\n\n\n\n\n\n","category":"function"},{"location":"reference/#keccak-reference","page":"Reference","title":"Keccak-based sponge construction","text":"","category":"section"},{"location":"reference/#Keccak.keccak_p","page":"Reference","title":"Keccak.keccak_p","text":"keccak_p(state, ::Val{nrounds})\n\nThe Kᴇᴄᴄᴀᴋ-p permutation function as defined in FIPS-202, with the number of rounds given by nrounds. The input state as well as the returned updated state are 25-tuples of unsigned integers of type T. Their LSB-first serialization corresponds to the bitstrings S and S′ in FIPS-202; its length b is determined by the type T. E.g. for T==UInt64, one obtains the commonly used b = 25 ⋅ 64 = 1600.\n\nFor example, for b=800 (hence T==UInt32), S=1000...000 corresponds to state == (0x00000001, (0x00000000 for _ in 2:25)...).\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances. E.g, for state::NTuple{25,SIMD.Vec{4,UInt64}}, it holds that\n\njulia> SIMD.Vec.((keccak_p(map(s -> s[n], state)) for n in 1:4)...) == keccak_p(state)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keccak.KeccakP","page":"Reference","title":"Keccak.KeccakP","text":"KeccakP{nrounds}\n\nConvenience wrapper for keccak_p with nrounds fixed.\n\nThis allows replacing constructions like state -> keccak_p(state, Val(nrounds)) with KeccakP{nrounds}():\n\njulia> const f1 = KeccakP{23}()\nKeccakP{23}()\n\njulia> const f2 = state -> keccak_p(state, Val(23))\n#2 (generic function with 1 method)\n\njulia> f1(state) == f2(state) == keccak_p(state, Val(23)) # for suitable state\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#Keccak.KeccakPad","page":"Reference","title":"Keccak.KeccakPad","text":"KeccakPad\n\nA padding function performing the Kᴇᴄᴄᴀᴋ pad10*1 padding with optional suffix bits inserted first for domain separation. These suffix bits are specified by providing a byte that includes the first 1 bit of the padding.\n\nE.g. for SHA3, the domain separation suffix is 01, so the padding appends 011000...0001. Noting the LSB-first convention, the first byte of the padding thus has to be 0b00000110 == 0x06, and the corresponding padding function would be instantiated with KeccakPad(0x06).\n\nnote: Note\nOnly up to six domain separation suffix bits are supported, so including the first padding 1 bit, the first byte has be between 0b00000001 (no suffix bits) and 0b01111111 (suffix 111111).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Keccak.KeccakSponge","page":"Reference","title":"Keccak.KeccakSponge","text":"KeccakSponge{R,T,nrounds}\n\nA Sponge specialization for Kᴇᴄᴄᴀᴋ:\n\nThe permutation function is KeccakP{nrounds}.\nThe sponge contents are a 25-tuple of T, which must be an unsigned integer or a SIMD.Vec thereof.\nThe rate in bits is given by 8*sizeof(T)*R (or 8*sizeof(eltype(T))*R) if T<:SIMD.Vec).\n\n\n\n\n\n","category":"type"},{"location":"#Keccak.jl-Documentation","page":"Home","title":"Keccak.jl Documentation","text":"","category":"section"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The two most important, i.e. most commonly used, algorithms this package provides, namely SHA-3 and SHAKE, are available is the SHA stdlib as well. So why use Keccak?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Flexibility. Not only does Keccak offer more readily available algorithms, it also provides the building blocks to implement further Keccak-based algorithms outside of the package. (Also, it allows things like turning SHA-3 into a SHAKE-like PRF by producing more output data from it than intended by the standard. One might consider this a bit too much flexibility, though.)\nPerformance. The Keccak implementations are (at present) faster and do not allocate. While the run-time of the SHA implementations might be improved in the future, the fact that they allocate memory is to some extent baked into the API and hence, not likely to change. Furthermore, in admittedly limited application scenarios, Keccak allows SIMD processing to further speed up simultaneous computation of multiple hashes.","category":"page"},{"location":"#For-the-impatient","page":"Home","title":"For the impatient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Great, more performance is always a good thing. I'd like to replace SHA with Keccak for computing SHA-3 hashes. How do I do it?","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming you have added Keccak to your project using Pkg, your ready to compute your first SHA-3 digest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Keccak: sha3_256\n\njulia> sha3_256(\"a message to compute the digest of\")\n(0xfa, 0x24, 0x49, 0x91, 0xa1, 0x94, 0x44, 0x1e, 0xd6, 0xa8, 0x34, 0x19, 0xd2, 0x00, 0x44, 0x12, 0x15, 0xa9, 0x7c, 0x49, 0xc6, 0xcf, 0x5e, 0x28, 0x7f, 0x75, 0x75, 0x45, 0x73, 0x6d, 0x25, 0x23)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In fact, you can use sha3_224, sha3_256, sha3_384, and sha3_512 almost as drop-in replacements for their counterparts from SHA, paying attention to the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SHA and Keccak export functions with the same names, so watch out for name clashes when using both. (Explicit using states as above are recommended anyway.)\nThe digest is returned as a tuple rather than a vector. Ideally, you can process the tuple like you processed the vector from SHA. If needed, you can collect the tuple into a vector (at the cost of memory allocation, of course).\nDirectly hashing from IO objects is not supported (yet).","category":"page"},{"location":"#Going-further","page":"Home","title":"Going further","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get to know everything offered by Keccak it is recommended to start reading the user guide from the beginning, as its sections not only build on each other, but are also (more or less) ordered by importance.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"API described here is intended for internal use. Changing it in incompatible ways will not be considered a breaking change w.r.t versioning. If you feel the need to use any of this outside of Keccak.jl, feel free to open a Github issue about it.","category":"page"},{"location":"internals/#Sponge","page":"Internals","title":"Sponge","text":"","category":"section"},{"location":"internals/#Keccak.Sponge","page":"Internals","title":"Keccak.Sponge","text":"Sponge{R,T<:NTuple,Fxfm,Fpad}\n\nCryptographic sponge holding a fixed-length permutation function, state of that length, a function to apply padding, and an offset for byte-wise input and output.\n\nA Sponge allows absorbing and squeezing arbitrary-sized data chunks. Once per every rate bytes absorbed or squeezed, the permutation function is invoked. After the last absorb and before the first squeeze, pad should be called to perform any necessary padding. I.e. the valid sequence of operations on a sponge is: Any number (including zero) calls to absorb, exactly one call to pad, any number (including zero) calls to squeeze.\n\nNote that a Sponge is immutable; any operations updating it return an updated Sponge instead of mutating the given one.\n\nType parameters\n\nT: type of the NTuple holding the sponge contents\nR: the rate in units of the state elements (eltype(T))\nFxfm: type of the permutation function\nFpad: type of the padding function\n\nFields\n\ntransform: the permutation function invoked for every rate bytes absorbed or squeezed\npad: the padding function invoked by pad(::Sponge)\nstate: the sponge contents\nk: the write (while absorbing) or read (while squeezing) byte offset inside the state, between 0 (inclusive) and R*sizeof(eltype(T)) (exclusive)\n\nSIMD support\n\nIf T<:SIMD.Vec (i.e. the state tuple holds SIMD.Vecs), absorbing and squeezing treats the individual data paths separately (and the rate in bytes is given by R*sizeof(eltype(eltype(T)))) in this case.)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Keccak.AbsorbableData","page":"Internals","title":"Keccak.AbsorbableData","text":"AbsorbableData\n\nType alias for the type of data acceptable as input to absorb.\n\nIf a String is to be absorbed, its codeunits are used.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Keccak.update","page":"Internals","title":"Keccak.update","text":"update(sponge::Sponge, state, k)\n\nReturn a new Sponge of the same type as sponge with the same transform function, but with state and k replaced with the given values.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.lanetype","page":"Internals","title":"Keccak.lanetype","text":"lanetype(sponge::Sponge)\n\nReturns type of the sponge state data. For SIMD sponge, the eltype of the SIMD.Vec is returned. I.e. assuming the data is a Tuple{Vararg{T}}, then T is returned if T<:Unsigned and eltype(T) is returned if T<:SIMD.Vec.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.rate","page":"Internals","title":"Keccak.rate","text":"rate(sponge::Sponge)\n\nReturns the rate (in bytes) of the given sponge.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Kᴇᴄᴄᴀᴋ-Helpers","page":"Internals","title":"Kᴇᴄᴄᴀᴋ Helpers","text":"","category":"section"},{"location":"internals/#Keccak.ℓ","page":"Internals","title":"Keccak.ℓ","text":"ℓ(::Type{T<:Unsigned})\n\nReturns the base-2 logarithm of the bitwidth of values of type T.\n\nExamples\n\njulia> ℓ(UInt32)\n5\n\njulia> 2^5\n32\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.rc","page":"Internals","title":"Keccak.rc","text":"rc(t)\n\nEvaluate t rounds of a linear feedback shift register and return the leading bit after the final round as specified in Algorithm 5 of FIPS-202.\n\nThis function is used for computing the round constants by round_consts.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.round_consts","page":"Internals","title":"Keccak.round_consts","text":"round_consts(::Type{T}, ::Val{nrounds}=Val(12+2ℓ(T)))\n\nCompute the Keccak round constants for lane length w corresponding to the bitwidth of T and the given number fo rounds nrounds.\n\nThe return value is a tuple of Ts containing the round constants for round indices 12+2ℓ(T)-nrounds to 12+2ℓ(T)-1 in that order. The default for nrounds results in the first round index being 0.\n\nnote: Note\nIt is valid to have nrounds>12+2ℓ(T), so that round index starts negative.\n\nExamples\n\njulia> round_consts(UInt16)\n(0x0001, 0x8082, 0x808a, 0x8000, 0x808b, 0x0001, 0x8081, 0x8009, 0x008a, 0x0088, 0x8009, 0x000a, 0x808b, 0x008b, 0x8089, 0x8003, 0x8002, 0x0080, 0x800a, 0x000a)\n\njulia> round_consts(UInt8)\n(0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(10))\n(0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\njulia> round_consts(UInt8, Val(20))\n(0x02, 0x8a, 0x01, 0x82, 0x8a, 0x00, 0x8b, 0x01, 0x81, 0x09, 0x8a, 0x88, 0x09, 0x0a, 0x8b, 0x8b, 0x89, 0x03, 0x02, 0x80)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Kᴇᴄᴄᴀᴋ-step-mappings","page":"Internals","title":"Kᴇᴄᴄᴀᴋ step mappings","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These functions follow the specification in section 3.2 of FIPS-202.","category":"page"},{"location":"internals/#Keccak.ι","page":"Internals","title":"Keccak.ι","text":"ι(state, RC)\n\nPerform the step mapping ι (round-dependent modification of lane[0,0]) of the Keccak algorithm and return the updated state.\n\nInstead of the round index as in FIPS-202, the corresponding round constant RC is expected as the second argument.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.θ","page":"Internals","title":"Keccak.θ","text":"θ(state)\n\nPerform the step mapping θ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.π","page":"Internals","title":"Keccak.π","text":"π(state)\n\nPerform the step mapping π (permutation of the lanes) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.χ","page":"Internals","title":"Keccak.χ","text":"χ(state)\n\nPerform the nonlinear step mapping χ of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.ρ","page":"Internals","title":"Keccak.ρ","text":"ρ(state)\n\nPerform the step mapping ρ (bit rotation in each lane) of the Keccak algorithm and return the updated state.\n\nThe state is a 25-tuple of unsigned integers, related to state array A in FIPS-202 by\n\nA[x,y,z] == state[5y+x+1] >> z & 1\n\nfor x = 0,...,4, y = 0,...,4 and z = 0,...,w-1, where w is the bitwidth of the integers in state.\n\nAlternatively, the state can contain SIMD.Vecs of unsigned integers to perform a parallel transformation of multiple state instances.\n\n\n\n\n\n","category":"function"},{"location":"internals/#SP.800-185-helpers","page":"Internals","title":"SP.800-185 helpers","text":"","category":"section"},{"location":"internals/#Keccak.absorb_right_encoded","page":"Internals","title":"Keccak.absorb_right_encoded","text":"absorb_right_encoded(sponge::Sponge, x::Integer)\n\nAbsorbs the non-negative integer x into the given sponge after applying the \"right_encode\" operation from NIST SP.800-185 to it.\n\nnote: Note\nThe current implementation requires x ≤ typemax(UInt64).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.absorb_left_encoded","page":"Internals","title":"Keccak.absorb_left_encoded","text":"absorb_left_encoded(sponge::Sponge, x::Integer)\n\nAbsorbs the non-negative integer x into the given sponge after applying the \"left_encode\" operation from NIST SP.800-185 to it. Returns the updated sponge.\n\nnote: Note\nThe current implementation requires x ≤ typemax(UInt64).\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.absorb_encoded_string","page":"Internals","title":"Keccak.absorb_encoded_string","text":"absorb_encoded_string(sponge::Sponge, str::AbsorbableData)\n\nAbsorbs the string str (which can also be a Tuple or AbstractVector of UInt8s) into the given sponge after applying the \"encode_string\" operation from NIST SP.800-185 to it. Returns the updated sponge.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.absorb_ratepadded","page":"Internals","title":"Keccak.absorb_ratepadded","text":"absorb_ratepadded(f, sponge::Sponge)\n\nAbsorb data into the given sponge and zero-pad to a multiple of the sponges rate. The padding uses the \"bytepad\" operation from NIST SP.800-185, but is limited to \"w\" being the sponge's rate.\n\nThe data is provided implicitly by passing a function f that is called with a sponge and has to return an updated sponge with the data absorbed.\n\nExample\n\nabsorb_ratepadded(sponge) do sponge\n    return absorb_encoded_string(sponge, \"Test\")\nend == absorb(sponge, [\n    0x01, UInt8(rate(sponge)), # left_encode'd pad width w=rate(sponge)\n    # start of data produced by `f` (i.e. absorb_encoded_string)\n    0x01, UInt8(4*8),\n    codeunits(\"Test\")...,\n    # end of data produced by `f`\n    zeros(UInt8, rate(sponge)-8)... # absorbed 8 bytes so far, zero-pad up to rate\n])\n\n# output\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internals/#Keccak.KMACPad","page":"Internals","title":"Keccak.KMACPad","text":"KMACPad(basepad::KeccakPad, len::UInt64)\n\nA padding function that first appends (i.e. absorbs) 8*len after \"right_encode\"ing it and then invokes basepad.\n\n\n\n\n\n","category":"type"},{"location":"sp800-185/#SHA-3-Derived-Functions","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"","category":"section"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"This section describes the API for the functionality defined in NIST Special publication 800-185 SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and ParallelHash.","category":"page"},{"location":"sp800-185/#cSHAKE","page":"SHA-3 Derived Functions","title":"cSHAKE","text":"","category":"section"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"cSHAKE is an extension of SHAKE that allows domain separation with a \"function name\" and a \"customization string\". The API provided by cshake_128 and cshake_256 is similar to that of SHAKE, except for accepting two additional optional parameters:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> msg = \"a message to compute the digest of\";\n\njulia> cshake_128(msg, Val(10)) # equal to shake_128\n(0xd4, 0xa7, 0x25, 0x77, 0xde, 0x29, 0x05, 0x20, 0x9b, 0x35)\n\njulia> cshake_128(msg, Val(10), \"example\") # with a function name\n(0x13, 0x74, 0xed, 0x93, 0xc6, 0x7d, 0x22, 0x55, 0xad, 0x6d)\n\njulia> cshake_128(msg, Val(10), \"example\", \"customized\") # ... and customization\n(0x25, 0x21, 0x2b, 0x95, 0xee, 0x09, 0x86, 0xea, 0x8a, 0x90)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"As for SHAKE, giving the output length as a plain number (instead of Val) causes a Vector{UInt8} to be returned and omitting it entirely creates a sponge ready for squeezing:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = cshake_128(msg, \"example\"); # could take customization string a third parameter\n\njulia> squeeze(sponge, Val(10))[2]\n(0x13, 0x74, 0xed, 0x93, 0xc6, 0x7d, 0x22, 0x55, 0xad, 0x6d)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"It is also possible to create a sponge for (chunk-wise) absorption of input. However, the function name and customization string (if any) have to be given upon sponge construction:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = cshake_128_sponge(\"example\", \"customized\");\n\njulia> sponge = absorb(sponge, msg);\n\njulia> sponge = pad(sponge);\n\njulia> squeeze(sponge, Val(10))[2]\n(0x25, 0x21, 0x2b, 0x95, 0xee, 0x09, 0x86, 0xea, 0x8a, 0x90)","category":"page"},{"location":"sp800-185/#KMAC","page":"SHA-3 Derived Functions","title":"KMAC","text":"","category":"section"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"The Keccak Message Authentication Code (KMAC) extends cSHAKE to a keyed hash function. It offers the same security strengths, 128 bits and 256 bits, available as kmac_128 and kmac_256, respectively.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Computing a KMAC is straight-forward:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> kmac_128(\"secret_key\", \"message to authenticate\", Val(16))\n(0x65, 0x65, 0xf2, 0x69, 0xe5, 0x9e, 0x79, 0x12, 0xcf, 0x10, 0xc0, 0x38, 0x1f, 0x97, 0xd8, 0x35)\n\njulia> kmac_128(\"secret_key\", \"message to authenticate\", Val(16), \"optional customization\")\n(0xc5, 0xfc, 0xa4, 0x68, 0xad, 0x49, 0x44, 0xf8, 0x74, 0x2b, 0x5c, 0x16, 0x31, 0x90, 0x84, 0x57)\n\njulia> kmac_128(\"secret_key\", \"message to authenticate\", Val(10)) # output length is included in hash\n(0x58, 0x83, 0xac, 0x0e, 0xf4, 0x6b, 0x3a, 0x31, 0x65, 0xcc)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Chunked input (and output) is possible by creating sponge with kmac_128_sponge or kmac_256_sponge:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = kmac_128_sponge(\"secret_key\", 16, \"optional customization\");\n\njulia> sponge = absorb(sponge, \"message\");\n\njulia> sponge = absorb(sponge, \" to authenticate\");\n\njulia> sponge = pad(sponge);\n\njulia> squeeze(sponge, Val(16))[2] # repeat output length\n(0xc5, 0xfc, 0xa4, 0x68, 0xad, 0x49, 0x44, 0xf8, 0x74, 0x2b, 0x5c, 0x16, 0x31, 0x90, 0x84, 0x57)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"While it is possible to obtain an output of a different length than was specified when initializing the sponge, the resulting KMAC will not be standard-compliant. However, there is an arbitrary-length output variant (extensible output function, XOF) for this purpose. Calling kmac_xof_128 (or kmac_xof_256) instead of kmac_128 (kmac_256) computes a KMAC where the output length is not included in the hash:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> kmac_xof_128(\"secret_key\", \"message to authenticate\", Val(16))\n(0x7b, 0xca, 0x90, 0xfd, 0xf6, 0x1e, 0x9d, 0x1e, 0x96, 0x3f, 0xf0, 0xf6, 0x7e, 0x37, 0x2c, 0x21)\n\njulia> kmac_xof_128(\"secret_key\", \"message to authenticate\", Val(10)) # prefix of the above\n(0x7b, 0xca, 0x90, 0xfd, 0xf6, 0x1e, 0x9d, 0x1e, 0x96, 0x3f)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Omitting the length results in a sponge ready to be squeezed from:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = kmac_xof_128(\"secret_key\", \"message to authenticate\");\n\njulia> sponge, out1 = squeeze(sponge, Val(10));\n\njulia> out1\n(0x7b, 0xca, 0x90, 0xfd, 0xf6, 0x1e, 0x9d, 0x1e, 0x96, 0x3f)\n\njulia> squeeze(sponge, Val(6))[2] # next six bytes\n(0xf0, 0xf6, 0x7e, 0x37, 0x2c, 0x21)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"To enable chunk-wise input, the length argument can be omitted from kmac_128_sponge and kmac_256_sponge to obtain a sponge for KMAC XOF:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = kmac_128_sponge(\"secret_key\");\n\njulia> sponge = absorb(sponge, \"message to authenticate\");\n\njulia> sponge = pad(sponge);\n\njulia> squeeze(sponge, Val(10))[2]\n(0x7b, 0xca, 0x90, 0xfd, 0xf6, 0x1e, 0x9d, 0x1e, 0x96, 0x3f)","category":"page"},{"location":"sp800-185/#TupleHash","page":"SHA-3 Derived Functions","title":"TupleHash","text":"","category":"section"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"TupleHash is a SHA-3-derived hash function for hashing a collection of input byte-strings. It is available as tuplehash_128 and tuplehash_256 for security lengths 128 bits and 256 bits, respectively. The desired output length has to be specified and is included in the hash:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> tuplehash_128([\"abcd\", \"ef\"], Val(16))\n(0x9c, 0x68, 0x5d, 0x62, 0x70, 0xab, 0x35, 0x59, 0xcb, 0x34, 0x60, 0x07, 0x8b, 0xb2, 0x30, 0x2b)\n\njulia> tuplehash_128([\"abc\", \"def\"], Val(16)) # different partitioning of same data -> different hash\n(0xe9, 0xee, 0x78, 0x85, 0x9a, 0x46, 0x37, 0x69, 0xc3, 0xaa, 0x05, 0xcb, 0x3c, 0x41, 0x81, 0xa3)\n\njulia> tuplehash_128([\"abc\", \"def\"], Val(12)) # different output length -> different hash\n(0x20, 0x7e, 0x63, 0xbb, 0x5c, 0xae, 0xb1, 0x5e, 0x6e, 0xd9, 0x67, 0xf8)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Note that, contrary to what the name suggests, the collection of input byte-strings does not have to be passed as a tuple. Any iterator (that produces Strings, Vector{UInt8}s, or Tuple{Vararg{UInt8}}s) will do, including a tuple.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"There is also an arbitrary-length output variant available as tuplehash_xof_128 and tuplehash_xof_256:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> tuplehash_xof_128([\"abc\", \"def\"], Val(16))\n(0xf0, 0xde, 0xf4, 0x88, 0x9a, 0xed, 0x8e, 0x8f, 0x77, 0xc0, 0xef, 0xf1, 0x60, 0xa3, 0x80, 0x54)\n\njulia> tuplehash_xof_128([\"abc\", \"def\"], Val(12)) # prefix of the above\n(0xf0, 0xde, 0xf4, 0x88, 0x9a, 0xed, 0x8e, 0x8f, 0x77, 0xc0, 0xef, 0xf1)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Omitting the output length gives a sponge that can be squeezed from:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> sponge = tuplehash_xof_128([\"abc\", \"def\"]);\n\njulia> squeeze(sponge, Val(16))[2]\n(0xf0, 0xde, 0xf4, 0x88, 0x9a, 0xed, 0x8e, 0x8f, 0x77, 0xc0, 0xef, 0xf1, 0x60, 0xa3, 0x80, 0x54)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Chunked input is not supported, i.e. there is no function to create a sponge ready for absorption to produce a TupleHash.","category":"page"},{"location":"sp800-185/#ParallelHash","page":"SHA-3 Derived Functions","title":"ParallelHash","text":"","category":"section"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"ParallelHash is a SHA-3-derived hash function designed to allow exploiting parallelism. This is achieved by processing the input in independent blocks. The implementation in parallelhash_128 and parallelhash_256 (for security lengths of 128 and 256 bits, respectively) utilizes 4-fold SIMD and multithreading to maximize throughput.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"note: Note\nMulti-threading requires julia to be started with multi-threading enabled, e.g. by passing -t auto. The multi-threaded implementation allocates memory. If avoiding allocations is a priority, multi-threading can be disabled by passing the keyword argument threaded=false.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Usage is straight-forward:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> data = rand(UInt8, 1_000_000);\n\njulia> parallelhash_128(data, 1024, Val(16)) # blocks of size 1024\n(0x44, 0xd8, 0x5d, 0x94, 0xdc, 0x7e, 0xba, 0xe8, 0xee, 0x2f, 0xb4, 0x0a, 0xc8, 0x11, 0x1d, 0x4d)","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"note: Note\nThe choice of the block size has an effect on the run-time, but also on the result. It is therefore not only a tuning parameter, but will usually be determined by the context.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Another aspect to note is that the input data has to be an AbstractArray{UInt8} or a String. Contrary to all other hashing functions, Tuple{Vararg{UInt8}} is not supported. Given that ParallelHash is typically applied to long input data, this should not be a restriction in practice.","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"Similar to KMAC and TupleHash, a special XOF mode is supported where the output length is not hashed. This is provided by parallelhash_xof_128 and parallelhash_xof_256 which allow directly calculating the hash or creating a squeeze-ready sponge:","category":"page"},{"location":"sp800-185/","page":"SHA-3 Derived Functions","title":"SHA-3 Derived Functions","text":"julia> data = rand(UInt8, 1_000_000);\n\njulia> parallelhash_xof_128(data, 1024, Val(8))\n(0x7a, 0xb2, 0x0d, 0xa2, 0xea, 0x3f, 0x33, 0xb9)\n\njulia> parallelhash_xof_128(data, 1024, Val(16))\n(0x7a, 0xb2, 0x0d, 0xa2, 0xea, 0x3f, 0x33, 0xb9, 0xe8, 0xd6, 0xf8, 0xfc, 0x41, 0x39, 0x89, 0x67)\n\njulia> sponge = parallelhash_xof_128(data, 1024);\n\njulia> squeeze(sponge, Val(8))[2]\n(0x7a, 0xb2, 0x0d, 0xa2, 0xea, 0x3f, 0x33, 0xb9)","category":"page"}]
}
